// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required

namespace ABStudio.FileFormats.PVR
{
    /// <summary>***********************************************************************</summary>
    /// <remarks>
    /// <para>Values for each meta data type that PVRTexLib knows about.</para>
    /// <para>Texture arrays hinge on each surface being identical in all</para>
    /// <para>but content, including meta data. If the meta data varies even</para>
    /// <para>slightly then a new texture should be used.</para>
    /// <para>It is possible to write your own extension to get around this however.</para>
    /// <para>***********************************************************************</para>
    /// </remarks>
    public enum PVRTexLibMetaData
    {
        PVRTLMD_TextureAtlasCoords = 0,
        PVRTLMD_BumpData = 1,
        PVRTLMD_CubeMapOrder = 2,
        PVRTLMD_TextureOrientation = 3,
        PVRTLMD_BorderData = 4,
        PVRTLMD_Padding = 5,
        PVRTLMD_PerChannelType = 6,
        PVRTLMD_SupercompressionGlobalData = 7,
        PVRTLMD_MaxRange = 8,
        PVRTLMD_NumMetaDataTypes = 9
    }

    /// <summary>***********************************************************************</summary>
    /// <remarks>
    /// <para>Axis</para>
    /// <para>***********************************************************************</para>
    /// </remarks>
    public enum PVRTexLibAxis
    {
        PVRTLA_X = 0,
        PVRTLA_Y = 1,
        PVRTLA_Z = 2
    }

    /// <summary>***********************************************************************</summary>
    /// <remarks>
    /// <para>Image orientations per axis</para>
    /// <para>***********************************************************************</para>
    /// </remarks>
    [Flags]
    public enum PVRTexLibOrientation
    {
        PVRTLO_Left = 1,
        PVRTLO_Right = 0,
        PVRTLO_Up = 2,
        PVRTLO_Down = 0,
        PVRTLO_Out = 4,
        PVRTLO_In = 0
    }

    /// <summary>***********************************************************************</summary>
    /// <remarks>
    /// <para>Describes the colour space of the texture</para>
    /// <para>***********************************************************************</para>
    /// </remarks>
    public enum PVRTexLibColourSpace
    {
        PVRTLCS_Linear = 0,
        PVRTLCS_sRGB = 1,
        PVRTLCS_BT601 = 2,
        PVRTLCS_BT709 = 3,
        PVRTLCS_BT2020 = 4,
        PVRTLCS_NumSpaces = 5
    }

    /// <summary>***********************************************************************</summary>
    /// <remarks>
    /// <para>Channel names for non-compressed formats</para>
    /// <para>***********************************************************************</para>
    /// </remarks>
    public enum PVRTexLibChannelName
    {
        PVRTLCN_NoChannel = 0,
        PVRTLCN_Red = 1,
        PVRTLCN_Green = 2,
        PVRTLCN_Blue = 3,
        PVRTLCN_Alpha = 4,
        PVRTLCN_Luminance = 5,
        PVRTLCN_Intensity = 6,
        PVRTLCN_Depth = 7,
        PVRTLCN_Stencil = 8,
        PVRTLCN_Unspecified = 9,
        PVRTLCN_NumChannels = 10
    }

    /// <summary>***********************************************************************</summary>
    /// <remarks>
    /// <para>Compressed pixel formats that PVRTexLib understands</para>
    /// <para>***********************************************************************</para>
    /// </remarks>
    public enum PVRTexLibPixelFormat
    {
        PVRTLPF_PVRTCI_2bppRGB = 0,
        PVRTLPF_PVRTCI_2bppRGBA = 1,
        PVRTLPF_PVRTCI_4bppRGB = 2,
        PVRTLPF_PVRTCI_4bppRGBA = 3,
        PVRTLPF_PVRTCII_2bpp = 4,
        PVRTLPF_PVRTCII_4bpp = 5,
        PVRTLPF_ETC1 = 6,
        PVRTLPF_DXT1 = 7,
        PVRTLPF_DXT2 = 8,
        PVRTLPF_DXT3 = 9,
        PVRTLPF_DXT4 = 10,
        PVRTLPF_DXT5 = 11,
        PVRTLPF_BC1 = 7,
        PVRTLPF_BC2 = 9,
        PVRTLPF_BC3 = 11,
        PVRTLPF_BC4 = 12,
        PVRTLPF_BC5 = 13,
        PVRTLPF_BC6 = 14,
        PVRTLPF_BC7 = 15,
        PVRTLPF_UYVY_422 = 16,
        PVRTLPF_YUY2_422 = 17,
        PVRTLPF_BW1bpp = 18,
        PVRTLPF_SharedExponentR9G9B9E5 = 19,
        PVRTLPF_RGBG8888 = 20,
        PVRTLPF_GRGB8888 = 21,
        PVRTLPF_ETC2RGB = 22,
        PVRTLPF_ETC2RGBA = 23,
        PVRTLPF_ETC2RGB_A1 = 24,
        PVRTLPF_EAC_R11 = 25,
        PVRTLPF_EAC_RG11 = 26,
        PVRTLPF_ASTC_4x4 = 27,
        PVRTLPF_ASTC_5x4 = 28,
        PVRTLPF_ASTC_5x5 = 29,
        PVRTLPF_ASTC_6x5 = 30,
        PVRTLPF_ASTC_6x6 = 31,
        PVRTLPF_ASTC_8x5 = 32,
        PVRTLPF_ASTC_8x6 = 33,
        PVRTLPF_ASTC_8x8 = 34,
        PVRTLPF_ASTC_10x5 = 35,
        PVRTLPF_ASTC_10x6 = 36,
        PVRTLPF_ASTC_10x8 = 37,
        PVRTLPF_ASTC_10x10 = 38,
        PVRTLPF_ASTC_12x10 = 39,
        PVRTLPF_ASTC_12x12 = 40,
        PVRTLPF_ASTC_3x3x3 = 41,
        PVRTLPF_ASTC_4x3x3 = 42,
        PVRTLPF_ASTC_4x4x3 = 43,
        PVRTLPF_ASTC_4x4x4 = 44,
        PVRTLPF_ASTC_5x4x4 = 45,
        PVRTLPF_ASTC_5x5x4 = 46,
        PVRTLPF_ASTC_5x5x5 = 47,
        PVRTLPF_ASTC_6x5x5 = 48,
        PVRTLPF_ASTC_6x6x5 = 49,
        PVRTLPF_ASTC_6x6x6 = 50,
        PVRTLPF_BASISU_ETC1S = 51,
        PVRTLPF_BASISU_UASTC = 52,
        PVRTLPF_RGBM = 53,
        PVRTLPF_RGBD = 54,
        PVRTLPF_PVRTCI_HDR_6bpp = 55,
        PVRTLPF_PVRTCI_HDR_8bpp = 56,
        PVRTLPF_PVRTCII_HDR_6bpp = 57,
        PVRTLPF_PVRTCII_HDR_8bpp = 58,
        PVRTLPF_VYUA10MSB_444 = 59,
        PVRTLPF_VYUA10LSB_444 = 60,
        PVRTLPF_VYUA12MSB_444 = 61,
        PVRTLPF_VYUA12LSB_444 = 62,
        PVRTLPF_UYV10A2_444 = 63,
        PVRTLPF_UYVA16_444 = 64,
        PVRTLPF_YUYV16_422 = 65,
        PVRTLPF_UYVY16_422 = 66,
        PVRTLPF_YUYV10MSB_422 = 67,
        PVRTLPF_YUYV10LSB_422 = 68,
        PVRTLPF_UYVY10MSB_422 = 69,
        PVRTLPF_UYVY10LSB_422 = 70,
        PVRTLPF_YUYV12MSB_422 = 71,
        PVRTLPF_YUYV12LSB_422 = 72,
        PVRTLPF_UYVY12MSB_422 = 73,
        PVRTLPF_UYVY12LSB_422 = 74,
        PVRTLPF_YUV_3P_444 = 270,
        PVRTLPF_YUV10MSB_3P_444 = 271,
        PVRTLPF_YUV10LSB_3P_444 = 272,
        PVRTLPF_YUV12MSB_3P_444 = 273,
        PVRTLPF_YUV12LSB_3P_444 = 274,
        PVRTLPF_YUV16_3P_444 = 275,
        PVRTLPF_YUV_3P_422 = 276,
        PVRTLPF_YUV10MSB_3P_422 = 277,
        PVRTLPF_YUV10LSB_3P_422 = 278,
        PVRTLPF_YUV12MSB_3P_422 = 279,
        PVRTLPF_YUV12LSB_3P_422 = 280,
        PVRTLPF_YUV16_3P_422 = 281,
        PVRTLPF_YUV_3P_420 = 282,
        PVRTLPF_YUV10MSB_3P_420 = 283,
        PVRTLPF_YUV10LSB_3P_420 = 284,
        PVRTLPF_YUV12MSB_3P_420 = 285,
        PVRTLPF_YUV12LSB_3P_420 = 286,
        PVRTLPF_YUV16_3P_420 = 287,
        PVRTLPF_YVU_3P_420 = 288,
        PVRTLPF_YUV_2P_422 = 480,
        PVRTLPF_YUV10MSB_2P_422 = 481,
        PVRTLPF_YUV10LSB_2P_422 = 482,
        PVRTLPF_YUV12MSB_2P_422 = 483,
        PVRTLPF_YUV12LSB_2P_422 = 484,
        PVRTLPF_YUV16_2P_422 = 485,
        PVRTLPF_YUV_2P_420 = 486,
        PVRTLPF_YUV10MSB_2P_420 = 487,
        PVRTLPF_YUV10LSB_2P_420 = 488,
        PVRTLPF_YUV12MSB_2P_420 = 489,
        PVRTLPF_YUV12LSB_2P_420 = 490,
        PVRTLPF_YUV16_2P_420 = 491,
        PVRTLPF_YUV_2P_444 = 492,
        PVRTLPF_YVU_2P_444 = 493,
        PVRTLPF_YUV10MSB_2P_444 = 494,
        PVRTLPF_YUV10LSB_2P_444 = 495,
        PVRTLPF_YVU10MSB_2P_444 = 496,
        PVRTLPF_YVU10LSB_2P_444 = 497,
        PVRTLPF_YVU_2P_422 = 498,
        PVRTLPF_YVU10MSB_2P_422 = 499,
        PVRTLPF_YVU10LSB_2P_422 = 500,
        PVRTLPF_YVU_2P_420 = 501,
        PVRTLPF_YVU10MSB_2P_420 = 502,
        PVRTLPF_YVU10LSB_2P_420 = 503,
        PVRTLPF_NumCompressedPFs = 504
    }

    /// <summary>***********************************************************************</summary>
    /// <remarks>
    /// <para>Data types. Describes how the data is interpreted by PVRTexLib and</para>
    /// <para>how the pointer returned by PVRTexLib_GetTextureDataPtr() should</para>
    /// <para>be interpreted.</para>
    /// <para>***********************************************************************</para>
    /// </remarks>
    public enum PVRTexLibVariableType
    {
        PVRTLVT_UnsignedByteNorm = 0,
        PVRTLVT_SignedByteNorm = 1,
        PVRTLVT_UnsignedByte = 2,
        PVRTLVT_SignedByte = 3,
        PVRTLVT_UnsignedShortNorm = 4,
        PVRTLVT_SignedShortNorm = 5,
        PVRTLVT_UnsignedShort = 6,
        PVRTLVT_SignedShort = 7,
        PVRTLVT_UnsignedIntegerNorm = 8,
        PVRTLVT_SignedIntegerNorm = 9,
        PVRTLVT_UnsignedInteger = 10,
        PVRTLVT_SignedInteger = 11,
        PVRTLVT_SignedFloat = 12,
        PVRTLVT_Float = 12,
        PVRTLVT_UnsignedFloat = 13,
        PVRTLVT_NumVarTypes = 14,
        PVRTLVT_Invalid = 255
    }

    /// <summary>***********************************************************************</summary>
    /// <remarks>
    /// <para>Quality level to compress the texture with. Applies to PVRTC,</para>
    /// <para>ETC, ASTC, BASIS and IMGIC formats.</para>
    /// <para>***********************************************************************</para>
    /// </remarks>
    public enum PVRTexLibCompressorQuality
    {
        /// <summary>PVRTC fastest</summary>
        PVRTLCQ_PVRTCFastest = 0,
        /// <summary>PVRTC fast</summary>
        PVRTLCQ_PVRTCFast = 1,
        /// <summary>PVRTC low</summary>
        PVRTLCQ_PVRTCLow = 2,
        /// <summary>PVRTC normal</summary>
        PVRTLCQ_PVRTCNormal = 3,
        /// <summary>PVRTC high</summary>
        PVRTLCQ_PVRTCHigh = 4,
        /// <summary>PVRTC very high</summary>
        PVRTLCQ_PVRTCVeryHigh = 5,
        /// <summary>PVRTC thorough</summary>
        PVRTLCQ_PVRTCThorough = 6,
        /// <summary>PVRTC best</summary>
        PVRTLCQ_PVRTCBest = 7,
        /// <summary>Number of PVRTC modes</summary>
        PVRTLCQ_NumPVRTCModes = 8,
        /// <summary>ETC fast</summary>
        PVRTLCQ_ETCFast = 0,
        /// <summary>ETC normal</summary>
        PVRTLCQ_ETCNormal = 1,
        /// <summary>ETC slow</summary>
        PVRTLCQ_ETCSlow = 2,
        /// <summary>Number of ETC modes</summary>
        PVRTLCQ_NumETCModes = 3,
        /// <summary>ASTC very fast</summary>
        PVRTLCQ_ASTCVeryFast = 0,
        /// <summary>ASTC fast</summary>
        PVRTLCQ_ASTCFast = 1,
        /// <summary>ASTC medium</summary>
        PVRTLCQ_ASTCMedium = 2,
        /// <summary>ASTC thorough</summary>
        PVRTLCQ_ASTCThorough = 3,
        /// <summary>ASTC exhaustive</summary>
        PVRTLCQ_ASTCExhaustive = 4,
        /// <summary>Number of ASTC modes</summary>
        PVRTLCQ_NumASTCModes = 5,
        /// <summary>BASISU lowest quality</summary>
        PVRTLCQ_BASISULowest = 0,
        /// <summary>BASISU low quality</summary>
        PVRTLCQ_BASISULow = 1,
        /// <summary>BASISU normal quality</summary>
        PVRTLCQ_BASISUNormal = 2,
        /// <summary>BASISU high quality</summary>
        PVRTLCQ_BASISUHigh = 3,
        /// <summary>BASISU best quality</summary>
        PVRTLCQ_BASISUBest = 4,
        /// <summary>Number of BASISU modes</summary>
        PVRTLCQ_NumBASISUModes = 5
    }

    /// <summary>***********************************************************************</summary>
    /// <remarks>
    /// <para>Filter to apply when resizing an image</para>
    /// <para>***********************************************************************</para>
    /// </remarks>
    public enum PVRTexLibResizeMode
    {
        /// <summary>Nearest filtering</summary>
        PVRTLRM_Nearest = 0,
        /// <summary>Linear filtering</summary>
        PVRTLRM_Linear = 1,
        /// <summary>Cubic filtering, uses Catmull-Rom splines.</summary>
        PVRTLRM_Cubic = 2,
        /// <summary>Number of resize modes</summary>
        PVRTLRM_Modes = 3
    }

    /// <summary>***********************************************************************</summary>
    /// <remarks>
    /// <para>File container type</para>
    /// <para>***********************************************************************</para>
    /// </remarks>
    public enum PVRTexLibFileContainerType
    {
        /// <summary>PVR: https://docs.imgtec.com/Specifications/PVR_File_Format_Specification/topics/pvr_intro.html</summary>
        PVRTLFCT_PVR = 0,
        /// <summary>KTX version 1: https://www.khronos.org/registry/KTX/specs/1.0/ktxspec_v1.html</summary>
        PVRTLFCT_KTX = 1,
        /// <summary>KTX version 2: https://github.khronos.org/KTX-Specification/</summary>
        PVRTLFCT_KTX2 = 2,
        /// <summary>ASTC compressed textures only: https://github.com/ARM-software/astc-encoder</summary>
        PVRTLFCT_ASTC = 3,
        /// <summary>Basis Universal compressed textures only: https://github.com/BinomialLLC/basis_universal</summary>
        PVRTLFCT_BASIS = 4,
        /// <summary>DirectDraw Surface: https://docs.microsoft.com/en-us/windows/win32/direct3ddds/dx-graphics-dds-reference</summary>
        PVRTLFCT_DDS = 5,
        /// <summary>C style header</summary>
        PVRTLFCT_CHeader = 6
    }

    /// <summary>***********************************************************************</summary>
    /// <remarks>
    /// <para>The clamping mode to use when performing a colour diff</para>
    /// <para>***********************************************************************</para>
    /// </remarks>
    public enum PVRTexLibColourDiffMode
    {
        /// <summary>Absolute</summary>
        PVRTLCDM_Abs = 0,
        /// <summary>Signed</summary>
        PVRTLCDM_Signed = 1
    }

    /// <summary>***********************************************************************</summary>
    /// <remarks>
    /// <para>Legacy API enum.</para>
    /// <para>***********************************************************************</para>
    /// </remarks>
    public enum PVRTexLibLegacyApi
    {
        /// <summary>OpenGL ES 1.x</summary>
        PVRTLLAPI_OGLES = 1,
        /// <summary>OpenGL ES 2.0</summary>
        PVRTLLAPI_OGLES2 = 2,
        /// <summary>Direct 3D M</summary>
        PVRTLLAPI_D3DM = 3,
        /// <summary>Open GL</summary>
        PVRTLLAPI_OGL = 4,
        /// <summary>DirextX 9</summary>
        PVRTLLAPI_DX9 = 5,
        /// <summary>DirectX 10</summary>
        PVRTLLAPI_DX10 = 6,
        /// <summary>Open VG</summary>
        PVRTLLAPI_OVG = 7,
        /// <summary>MGL</summary>
        PVRTLLAPI_MGL = 8
    }

    /// <summary>
    /// <para>**************************************************************************</para>
    /// <para>* Integer types</para>
    /// <para>**************************************************************************</para>
    /// </summary>
    public unsafe partial class PVRTextureHeaderV3 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 52, Pack = 4)]
        public partial struct __Internal
        {
            internal uint u32Version;
            internal uint u32Flags;
            internal ulong u64PixelFormat;
            internal uint u32ColourSpace;
            internal uint u32ChannelType;
            internal uint u32Height;
            internal uint u32Width;
            internal uint u32Depth;
            internal uint u32NumSurfaces;
            internal uint u32NumFaces;
            internal uint u32MIPMapCount;
            internal uint u32MetaDataSize;

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "??0PVRTextureHeaderV3@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, PVRTextureHeaderV3> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, PVRTextureHeaderV3>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, PVRTextureHeaderV3 managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out PVRTextureHeaderV3 managed)
        {

            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static PVRTextureHeaderV3 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new PVRTextureHeaderV3(native.ToPointer(), skipVTables);
        }

        internal static PVRTextureHeaderV3 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (PVRTextureHeaderV3)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static PVRTextureHeaderV3 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new PVRTextureHeaderV3(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private PVRTextureHeaderV3(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected PVRTextureHeaderV3(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public PVRTextureHeaderV3()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(PVRTextureHeaderV3.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public PVRTextureHeaderV3(PVRTextureHeaderV3 _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(PVRTextureHeaderV3.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((PVRTextureHeaderV3.__Internal*)__Instance) = *((PVRTextureHeaderV3.__Internal*)_0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Version of the file header, used to identify it.</summary>
        public uint U32Version
        {
            get
            {
                return ((__Internal*)__Instance)->u32Version;
            }

            set
            {
                ((__Internal*)__Instance)->u32Version = value;
            }
        }

        /// <summary>Various format flags.</summary>
        public uint U32Flags
        {
            get
            {
                return ((__Internal*)__Instance)->u32Flags;
            }

            set
            {
                ((__Internal*)__Instance)->u32Flags = value;
            }
        }

        /// <summary>The pixel format, 8cc value storing the 4 channel identifiers and their respective sizes.</summary>
        public ulong U64PixelFormat
        {
            get
            {
                return ((__Internal*)__Instance)->u64PixelFormat;
            }

            set
            {
                ((__Internal*)__Instance)->u64PixelFormat = value;
            }
        }

        /// <summary>The Colour Space of the texture, currently either linear RGB or sRGB.</summary>
        public uint U32ColourSpace
        {
            get
            {
                return ((__Internal*)__Instance)->u32ColourSpace;
            }

            set
            {
                ((__Internal*)__Instance)->u32ColourSpace = value;
            }
        }

        /// <summary>Variable type that the channel is stored in. Supports signed/unsigned int/short/byte or float for now.</summary>
        public uint U32ChannelType
        {
            get
            {
                return ((__Internal*)__Instance)->u32ChannelType;
            }

            set
            {
                ((__Internal*)__Instance)->u32ChannelType = value;
            }
        }

        /// <summary>Height of the texture.</summary>
        public uint U32Height
        {
            get
            {
                return ((__Internal*)__Instance)->u32Height;
            }

            set
            {
                ((__Internal*)__Instance)->u32Height = value;
            }
        }

        /// <summary>Width of the texture.</summary>
        public uint U32Width
        {
            get
            {
                return ((__Internal*)__Instance)->u32Width;
            }

            set
            {
                ((__Internal*)__Instance)->u32Width = value;
            }
        }

        /// <summary>Depth of the texture. (Z-slices)</summary>
        public uint U32Depth
        {
            get
            {
                return ((__Internal*)__Instance)->u32Depth;
            }

            set
            {
                ((__Internal*)__Instance)->u32Depth = value;
            }
        }

        /// <summary>Number of members in a Texture Array.</summary>
        public uint U32NumSurfaces
        {
            get
            {
                return ((__Internal*)__Instance)->u32NumSurfaces;
            }

            set
            {
                ((__Internal*)__Instance)->u32NumSurfaces = value;
            }
        }

        /// <summary>Number of faces in a Cube Map. Maybe be a value other than 6.</summary>
        public uint U32NumFaces
        {
            get
            {
                return ((__Internal*)__Instance)->u32NumFaces;
            }

            set
            {
                ((__Internal*)__Instance)->u32NumFaces = value;
            }
        }

        /// <summary>Number of MIP Maps in the texture - NB: Includes top level.</summary>
        public uint U32MIPMapCount
        {
            get
            {
                return ((__Internal*)__Instance)->u32MIPMapCount;
            }

            set
            {
                ((__Internal*)__Instance)->u32MIPMapCount = value;
            }
        }

        /// <summary>Size of the accompanying meta data.</summary>
        public uint U32MetaDataSize
        {
            get
            {
                return ((__Internal*)__Instance)->u32MetaDataSize;
            }

            set
            {
                ((__Internal*)__Instance)->u32MetaDataSize = value;
            }
        }
    }

    /// <summary>***********************************************************************</summary>
    /// <remarks>
    /// <para>Structure containing various texture header parameters for</para>
    /// <para>PVRTexLib_CreateTextureHeader().</para>
    /// <para>***********************************************************************</para>
    /// </remarks>
    public unsafe partial class PVRHeaderCreateParams : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 48)]
        public partial struct __Internal
        {
            internal ulong pixelFormat;
            internal uint width;
            internal uint height;
            internal uint depth;
            internal uint numMipMaps;
            internal uint numArrayMembers;
            internal uint numFaces;
            internal PVRTexLibColourSpace colourSpace;
            internal PVRTexLibVariableType channelType;
            internal byte preMultiplied;

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "??0PVRHeader_CreateParams@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, PVRHeaderCreateParams> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, PVRHeaderCreateParams>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, PVRHeaderCreateParams managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out PVRHeaderCreateParams managed)
        {

            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static PVRHeaderCreateParams __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new PVRHeaderCreateParams(native.ToPointer(), skipVTables);
        }

        internal static PVRHeaderCreateParams __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (PVRHeaderCreateParams)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static PVRHeaderCreateParams __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new PVRHeaderCreateParams(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private PVRHeaderCreateParams(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected PVRHeaderCreateParams(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public PVRHeaderCreateParams()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(PVRHeaderCreateParams.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public PVRHeaderCreateParams(PVRHeaderCreateParams _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(PVRHeaderCreateParams.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((PVRHeaderCreateParams.__Internal*)__Instance) = *((PVRHeaderCreateParams.__Internal*)_0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>pixel format</summary>
        public ulong PixelFormat
        {
            get
            {
                return ((__Internal*)__Instance)->pixelFormat;
            }

            set
            {
                ((__Internal*)__Instance)->pixelFormat = value;
            }
        }

        /// <summary>texture width</summary>
        public uint Width
        {
            get
            {
                return ((__Internal*)__Instance)->width;
            }

            set
            {
                ((__Internal*)__Instance)->width = value;
            }
        }

        /// <summary>texture height</summary>
        public uint Height
        {
            get
            {
                return ((__Internal*)__Instance)->height;
            }

            set
            {
                ((__Internal*)__Instance)->height = value;
            }
        }

        /// <summary>texture depth</summary>
        public uint Depth
        {
            get
            {
                return ((__Internal*)__Instance)->depth;
            }

            set
            {
                ((__Internal*)__Instance)->depth = value;
            }
        }

        /// <summary>number of MIP maps</summary>
        public uint NumMipMaps
        {
            get
            {
                return ((__Internal*)__Instance)->numMipMaps;
            }

            set
            {
                ((__Internal*)__Instance)->numMipMaps = value;
            }
        }

        /// <summary>number of array members</summary>
        public uint NumArrayMembers
        {
            get
            {
                return ((__Internal*)__Instance)->numArrayMembers;
            }

            set
            {
                ((__Internal*)__Instance)->numArrayMembers = value;
            }
        }

        /// <summary>number of faces</summary>
        public uint NumFaces
        {
            get
            {
                return ((__Internal*)__Instance)->numFaces;
            }

            set
            {
                ((__Internal*)__Instance)->numFaces = value;
            }
        }

        /// <summary>colour space</summary>
        public PVRTexLibColourSpace ColourSpace
        {
            get
            {
                return ((__Internal*)__Instance)->colourSpace;
            }

            set
            {
                ((__Internal*)__Instance)->colourSpace = value;
            }
        }

        /// <summary>channel type</summary>
        public PVRTexLibVariableType ChannelType
        {
            get
            {
                return ((__Internal*)__Instance)->channelType;
            }

            set
            {
                ((__Internal*)__Instance)->channelType = value;
            }
        }

        /// <summary>has the RGB been pre-multiplied by the alpha?</summary>
        public bool PreMultiplied
        {
            get
            {
                return ((__Internal*)__Instance)->preMultiplied != 0;
            }

            set
            {
                ((__Internal*)__Instance)->preMultiplied = (byte)(value ? 1 : 0);
            }
        }
    }

    /// <summary>***********************************************************************</summary>
    /// <remarks>
    /// <para>Structure containing a textures orientation in each axis.</para>
    /// <para>***********************************************************************</para>
    /// </remarks>
    public unsafe partial class PVRTexLib_Orientation : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            internal PVRTexLibOrientation x;
            internal PVRTexLibOrientation y;
            internal PVRTexLibOrientation z;

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "??0PVRTexLib_Orientation@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, PVRTexLib_Orientation> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, PVRTexLib_Orientation>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, PVRTexLib_Orientation managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out PVRTexLib_Orientation managed)
        {

            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static PVRTexLib_Orientation __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new PVRTexLib_Orientation(native.ToPointer(), skipVTables);
        }

        internal static PVRTexLib_Orientation __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (PVRTexLib_Orientation)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static PVRTexLib_Orientation __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new PVRTexLib_Orientation(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private PVRTexLib_Orientation(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected PVRTexLib_Orientation(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public PVRTexLib_Orientation()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(PVRTexLib_Orientation.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public PVRTexLib_Orientation(PVRTexLib_Orientation _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(PVRTexLib_Orientation.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((PVRTexLib_Orientation.__Internal*)__Instance) = *((PVRTexLib_Orientation.__Internal*)_0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>X axis orientation</summary>
        public PVRTexLibOrientation X
        {
            get
            {
                return ((__Internal*)__Instance)->x;
            }

            set
            {
                ((__Internal*)__Instance)->x = value;
            }
        }

        /// <summary>Y axis orientation</summary>
        public PVRTexLibOrientation Y
        {
            get
            {
                return ((__Internal*)__Instance)->y;
            }

            set
            {
                ((__Internal*)__Instance)->y = value;
            }
        }

        /// <summary>Z axis orientation</summary>
        public PVRTexLibOrientation Z
        {
            get
            {
                return ((__Internal*)__Instance)->z;
            }

            set
            {
                ((__Internal*)__Instance)->z = value;
            }
        }
    }

    /// <summary>***********************************************************************</summary>
    /// <remarks>
    /// <para>Structure containing a OpenGL[ES] format.</para>
    /// <para>***********************************************************************</para>
    /// </remarks>
    public unsafe partial class PVRTexLibOpenGLFormat : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            internal uint internalFormat;
            internal uint format;
            internal uint type;

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "??0PVRTexLib_OpenGLFormat@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, PVRTexLibOpenGLFormat> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, PVRTexLibOpenGLFormat>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, PVRTexLibOpenGLFormat managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out PVRTexLibOpenGLFormat managed)
        {

            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static PVRTexLibOpenGLFormat __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new PVRTexLibOpenGLFormat(native.ToPointer(), skipVTables);
        }

        internal static PVRTexLibOpenGLFormat __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (PVRTexLibOpenGLFormat)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static PVRTexLibOpenGLFormat __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new PVRTexLibOpenGLFormat(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private PVRTexLibOpenGLFormat(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected PVRTexLibOpenGLFormat(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public PVRTexLibOpenGLFormat()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(PVRTexLibOpenGLFormat.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public PVRTexLibOpenGLFormat(PVRTexLibOpenGLFormat _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(PVRTexLibOpenGLFormat.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((PVRTexLibOpenGLFormat.__Internal*)__Instance) = *((PVRTexLibOpenGLFormat.__Internal*)_0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>GL internal format</summary>
        public uint InternalFormat
        {
            get
            {
                return ((__Internal*)__Instance)->internalFormat;
            }

            set
            {
                ((__Internal*)__Instance)->internalFormat = value;
            }
        }

        /// <summary>GL format</summary>
        public uint Format
        {
            get
            {
                return ((__Internal*)__Instance)->format;
            }

            set
            {
                ((__Internal*)__Instance)->format = value;
            }
        }

        /// <summary>GL type</summary>
        public uint Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }
    }

    /// <summary>***********************************************************************</summary>
    /// <remarks>
    /// <para>Structure containing a block of meta data for a texture.</para>
    /// <para>***********************************************************************</para>
    /// </remarks>
    public unsafe partial class PVRTexLibMetaDataBlock : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal uint DevFOURCC;
            internal uint u32Key;
            internal uint u32DataSize;
            internal __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "??0PVRTexLib_MetaDataBlock@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, PVRTexLibMetaDataBlock> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, PVRTexLibMetaDataBlock>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, PVRTexLibMetaDataBlock managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out PVRTexLibMetaDataBlock managed)
        {

            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static PVRTexLibMetaDataBlock __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new PVRTexLibMetaDataBlock(native.ToPointer(), skipVTables);
        }

        internal static PVRTexLibMetaDataBlock __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (PVRTexLibMetaDataBlock)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static PVRTexLibMetaDataBlock __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new PVRTexLibMetaDataBlock(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private PVRTexLibMetaDataBlock(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected PVRTexLibMetaDataBlock(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public PVRTexLibMetaDataBlock()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(PVRTexLibMetaDataBlock.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public PVRTexLibMetaDataBlock(PVRTexLibMetaDataBlock _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(PVRTexLibMetaDataBlock.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((PVRTexLibMetaDataBlock.__Internal*)__Instance) = *((PVRTexLibMetaDataBlock.__Internal*)_0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>A 4cc descriptor of the data type's creator. Values starting with 'PVR' are reserved for PVRTexLib.</summary>
        public uint DevFOURCC
        {
            get
            {
                return ((__Internal*)__Instance)->DevFOURCC;
            }

            set
            {
                ((__Internal*)__Instance)->DevFOURCC = value;
            }
        }

        /// <summary>A unique value identifying the data type, and thus how to read it. For example PVRTexLibMetaData.</summary>
        public uint U32Key
        {
            get
            {
                return ((__Internal*)__Instance)->u32Key;
            }

            set
            {
                ((__Internal*)__Instance)->u32Key = value;
            }
        }

        /// <summary>Size of 'Data' in bytes.</summary>
        public uint U32DataSize
        {
            get
            {
                return ((__Internal*)__Instance)->u32DataSize;
            }

            set
            {
                ((__Internal*)__Instance)->u32DataSize = value;
            }
        }

        /// <summary>Meta data bytes</summary>
        public byte* Data
        {
            get
            {
                return (byte*)((__Internal*)__Instance)->Data;
            }

            set
            {
                ((__Internal*)__Instance)->Data = (__IntPtr)value;
            }
        }
    }

    public unsafe partial class PVRTexLibTranscoderOptions : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 48, Pack = 4)]
        public partial struct __Internal
        {
            internal uint sizeofStruct;
            internal ulong pixelFormat;
            internal fixed int channelType[4];
            internal PVRTexLibColourSpace colourspace;
            internal PVRTexLibCompressorQuality quality;
            internal byte doDither;
            internal float maxRange;
            internal uint maxThreads;

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "??0PVRTexLib_TranscoderOptions@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, PVRTexLibTranscoderOptions> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, PVRTexLibTranscoderOptions>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, PVRTexLibTranscoderOptions managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out PVRTexLibTranscoderOptions managed)
        {

            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static PVRTexLibTranscoderOptions __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new PVRTexLibTranscoderOptions(native.ToPointer(), skipVTables);
        }

        internal static PVRTexLibTranscoderOptions __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (PVRTexLibTranscoderOptions)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static PVRTexLibTranscoderOptions __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new PVRTexLibTranscoderOptions(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private PVRTexLibTranscoderOptions(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected PVRTexLibTranscoderOptions(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public PVRTexLibTranscoderOptions()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(PVRTexLibTranscoderOptions.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public PVRTexLibTranscoderOptions(PVRTexLibTranscoderOptions _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(PVRTexLibTranscoderOptions.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((PVRTexLibTranscoderOptions.__Internal*)__Instance) = *((PVRTexLibTranscoderOptions.__Internal*)_0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>For versioning - sizeof(PVRTexLib_TranscoderOptions)</summary>
        public uint SizeofStruct
        {
            get
            {
                return ((__Internal*)__Instance)->sizeofStruct;
            }

            set
            {
                ((__Internal*)__Instance)->sizeofStruct = value;
            }
        }

        /// <summary>Pixel format type</summary>
        public ulong PixelFormat
        {
            get
            {
                return ((__Internal*)__Instance)->pixelFormat;
            }

            set
            {
                ((__Internal*)__Instance)->pixelFormat = value;
            }
        }

        /// <summary>Per-channel variable type.</summary>
        public PVRTexLibVariableType ChannelType0
        {
            get
            {
                return (PVRTexLibVariableType)((__Internal*)__Instance)->channelType[0];
            }

            set
            {
                ((__Internal*)__Instance)->channelType[0] = (int)value;
            }
        }

        /// <summary>Per-channel variable type.</summary>
        public PVRTexLibVariableType ChannelType1
        {
            get
            {
                return (PVRTexLibVariableType)((__Internal*)__Instance)->channelType[1];
            }

            set
            {
                ((__Internal*)__Instance)->channelType[1] = (int)value;
            }
        }

        /// <summary>Per-channel variable type.</summary>
        public PVRTexLibVariableType ChannelType2
        {
            get
            {
                return (PVRTexLibVariableType)((__Internal*)__Instance)->channelType[2];
            }

            set
            {
                ((__Internal*)__Instance)->channelType[2] = (int)value;
            }
        }

        /// <summary>Per-channel variable type.</summary>
        public PVRTexLibVariableType ChannelType3
        {
            get
            {
                return (PVRTexLibVariableType)((__Internal*)__Instance)->channelType[3];
            }

            set
            {
                ((__Internal*)__Instance)->channelType[3] = (int)value;
            }
        }

        /// <summary>Colour space</summary>
        public PVRTexLibColourSpace Colourspace
        {
            get
            {
                return ((__Internal*)__Instance)->colourspace;
            }

            set
            {
                ((__Internal*)__Instance)->colourspace = value;
            }
        }

        /// <summary>Compression quality for PVRTC, ASTC, ETC, BASISU and IMGIC, higher quality usually requires more processing time.</summary>
        public PVRTexLibCompressorQuality Quality
        {
            get
            {
                return ((__Internal*)__Instance)->quality;
            }

            set
            {
                ((__Internal*)__Instance)->quality = value;
            }
        }

        /// <summary>Apply dithering to lower precision formats.</summary>
        public bool DoDither
        {
            get
            {
                return ((__Internal*)__Instance)->doDither != 0;
            }

            set
            {
                ((__Internal*)__Instance)->doDither = (byte)(value ? 1 : 0);
            }
        }

        /// <summary>Max range value for RGB[M|D] encoding</summary>
        public float MaxRange
        {
            get
            {
                return ((__Internal*)__Instance)->maxRange;
            }

            set
            {
                ((__Internal*)__Instance)->maxRange = value;
            }
        }

        /// <summary>Max number of threads to use for transcoding, if set to 0 PVRTexLib will use all available cores.</summary>
        public uint MaxThreads
        {
            get
            {
                return ((__Internal*)__Instance)->maxThreads;
            }

            set
            {
                ((__Internal*)__Instance)->maxThreads = value;
            }
        }
    }

    /// <summary>***********************************************************************</summary>
    /// <remarks>
    /// <para>Structure containing the resulting error metrics computed by:</para>
    /// <para>PVRTexLib_MaxDifference(),</para>
    /// <para>PVRTexLib_MeanError(),</para>
    /// <para>PVRTexLib_MeanSquaredError(),</para>
    /// <para>PVRTexLib_RootMeanSquaredError(),</para>
    /// <para>PVRTexLib_StandardDeviation(),</para>
    /// <para>PVRTexLib_PeakSignalToNoiseRatio().</para>
    /// <para>***********************************************************************</para>
    /// </remarks>
    public unsafe partial class PVRTexLibErrorMetrics : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 80)]
        public partial struct __Internal
        {
            internal fixed byte channels[64];
            internal double allChannels;
            internal double rgbChannels;

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "??0PVRTexLib_ErrorMetrics@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public unsafe partial class _0 : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 16)]
            public partial struct __Internal
            {
                internal PVRTexLibChannelName name;
                internal double value;

                [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "??0<unnamed-type-channels>@PVRTexLib_ErrorMetrics@@QEAA@AEBU01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, PVRTexLibErrorMetrics._0> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, PVRTexLibErrorMetrics._0>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, PVRTexLibErrorMetrics._0 managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out PVRTexLibErrorMetrics._0 managed)
            {

                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static _0 __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new _0(native.ToPointer(), skipVTables);
            }

            internal static _0 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (_0)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static _0 __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new _0(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*)ret = native;
                return ret.ToPointer();
            }

            private _0(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected _0(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public _0()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(PVRTexLibErrorMetrics._0.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            public _0(PVRTexLibErrorMetrics._0 __0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(PVRTexLibErrorMetrics._0.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((PVRTexLibErrorMetrics._0.__Internal*)__Instance) = *((PVRTexLibErrorMetrics._0.__Internal*)__0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Channel name. PVRTLCN_NoChannel indicates invalid entry.</summary>
            public PVRTexLibChannelName Name
            {
                get
                {
                    return ((__Internal*)__Instance)->name;
                }

                set
                {
                    ((__Internal*)__Instance)->name = value;
                }
            }

            /// <summary>Value for this channel.</summary>
            public double Value
            {
                get
                {
                    return ((__Internal*)__Instance)->value;
                }

                set
                {
                    ((__Internal*)__Instance)->value = value;
                }
            }
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, PVRTexLibErrorMetrics> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, PVRTexLibErrorMetrics>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, PVRTexLibErrorMetrics managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out PVRTexLibErrorMetrics managed)
        {

            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static PVRTexLibErrorMetrics __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new PVRTexLibErrorMetrics(native.ToPointer(), skipVTables);
        }

        internal static PVRTexLibErrorMetrics __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (PVRTexLibErrorMetrics)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static PVRTexLibErrorMetrics __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new PVRTexLibErrorMetrics(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private PVRTexLibErrorMetrics(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected PVRTexLibErrorMetrics(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public PVRTexLibErrorMetrics()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(PVRTexLibErrorMetrics.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public PVRTexLibErrorMetrics(PVRTexLibErrorMetrics _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(PVRTexLibErrorMetrics.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((PVRTexLibErrorMetrics.__Internal*)__Instance) = *((PVRTexLibErrorMetrics.__Internal*)_0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Per-channel metrics, not all entries have to be valid.</summary>
        public PVRTexLibErrorMetrics._0[] Channels
        {
            get
            {
                PVRTexLibErrorMetrics._0[] __value = null;
                if (((__Internal*)__Instance)->channels != null)
                {
                    __value = new PVRTexLibErrorMetrics._0[4];
                    for (int i = 0; i < 4; i++)
                        __value[i] = PVRTexLibErrorMetrics._0.__GetOrCreateInstance((IntPtr)((PVRTexLibErrorMetrics._0.__Internal*)&(((__Internal*)__Instance)->channels[i * sizeof(PVRTexLibErrorMetrics._0.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 4)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 4; i++)
                        *(PVRTexLibErrorMetrics._0.__Internal*)&((__Internal*)__Instance)->channels[i * sizeof(PVRTexLibErrorMetrics._0.__Internal)] = *(PVRTexLibErrorMetrics._0.__Internal*)value[i].__Instance;
                }
            }
        }

        /// <summary>Value for all channels.</summary>
        public double AllChannels
        {
            get
            {
                return ((__Internal*)__Instance)->allChannels;
            }

            set
            {
                ((__Internal*)__Instance)->allChannels = value;
            }
        }

        /// <summary>Value for RGB channels.</summary>
        public double RgbChannels
        {
            get
            {
                return ((__Internal*)__Instance)->rgbChannels;
            }

            set
            {
                ((__Internal*)__Instance)->rgbChannels = value;
            }
        }
    }

    public unsafe partial class PVRTexLib
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_SetDefaultTextureHeaderParams", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PVRTexLibSetDefaultTextureHeaderParams(__IntPtr result);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_CreateTextureHeader", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr PVRTexLibCreateTextureHeader(__IntPtr attribs);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_CreateTextureHeaderFromHeader", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr PVRTexLibCreateTextureHeaderFromHeader(__IntPtr header, uint metaDataCount, __IntPtr metaData);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_CopyTextureHeader", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr PVRTexLibCopyTextureHeader(__IntPtr header);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_DestroyTextureHeader", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PVRTexLibDestroyTextureHeader(__IntPtr header);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_TextureCreateRaw", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr PVRTexLibTextureCreateRaw(uint width, uint height, uint depth, uint wMin, uint hMin, uint dMin, uint nBPP, bool bMIPMap, __IntPtr pfnAllocCallback);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_TextureLoadTiled", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PVRTexLibTextureLoadTiled(byte* pDst, uint widthDst, uint heightDst, byte* pSrc, uint widthSrc, uint heightSrc, uint elementSize, bool twiddled);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_GetTextureBitsPerPixel", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint PVRTexLibGetTextureBitsPerPixel(__IntPtr header);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_GetFormatBitsPerPixel", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint PVRTexLibGetFormatBitsPerPixel(ulong u64PixelFormat);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_GetTextureChannelCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint PVRTexLibGetTextureChannelCount(__IntPtr header);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_GetTextureChannelType", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern PVRTexLibVariableType PVRTexLibGetTextureChannelType(__IntPtr header);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_GetTextureColourSpace", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern PVRTexLibColourSpace PVRTexLibGetTextureColourSpace(__IntPtr header);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_GetTextureWidth", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint PVRTexLibGetTextureWidth(__IntPtr header, uint mipLevel);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_GetTextureHeight", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint PVRTexLibGetTextureHeight(__IntPtr header, uint mipLevel);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_GetTextureDepth", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint PVRTexLibGetTextureDepth(__IntPtr header, uint mipLevel);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_GetTextureSize", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint PVRTexLibGetTextureSize(__IntPtr header, int mipLevel, bool allSurfaces, bool allFaces);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_GetTextureDataSize", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong PVRTexLibGetTextureDataSize(__IntPtr header, int mipLevel, bool allSurfaces, bool allFaces);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_GetTextureOrientation", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PVRTexLibGetTextureOrientation(__IntPtr header, __IntPtr result);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_GetTextureOpenGLFormat", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PVRTexLibGetTextureOpenGLFormat(__IntPtr header, __IntPtr result);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_GetTextureOpenGLESFormat", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PVRTexLibGetTextureOpenGLESFormat(__IntPtr header, __IntPtr result);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_GetTextureVulkanFormat", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint PVRTexLibGetTextureVulkanFormat(__IntPtr header);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_GetTextureD3DFormat", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint PVRTexLibGetTextureD3DFormat(__IntPtr header);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_GetTextureDXGIFormat", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint PVRTexLibGetTextureDXGIFormat(__IntPtr header);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_GetTextureFormatMinDims", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PVRTexLibGetTextureFormatMinDims(__IntPtr header, uint* minX, uint* minY, uint* minZ);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_GetPixelFormatMinDims", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PVRTexLibGetPixelFormatMinDims(ulong ui64Format, uint* minX, uint* minY, uint* minZ);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_GetTextureMetaDataSize", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint PVRTexLibGetTextureMetaDataSize(__IntPtr header);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_GetTextureIsPreMultiplied", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PVRTexLibGetTextureIsPreMultiplied(__IntPtr header);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_GetTextureIsFileCompressed", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PVRTexLibGetTextureIsFileCompressed(__IntPtr header);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_GetTextureIsBumpMap", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PVRTexLibGetTextureIsBumpMap(__IntPtr header);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_GetTextureBumpMapScale", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float PVRTexLibGetTextureBumpMapScale(__IntPtr header);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_GetNumTextureAtlasMembers", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint PVRTexLibGetNumTextureAtlasMembers(__IntPtr header);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_GetTextureAtlasData", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float* PVRTexLibGetTextureAtlasData(__IntPtr header, uint* count);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_GetTextureNumMipMapLevels", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint PVRTexLibGetTextureNumMipMapLevels(__IntPtr header);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_GetTextureNumFaces", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint PVRTexLibGetTextureNumFaces(__IntPtr header);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_GetTextureNumArrayMembers", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint PVRTexLibGetTextureNumArrayMembers(__IntPtr header);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_GetTextureCubeMapOrder", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PVRTexLibGetTextureCubeMapOrder(__IntPtr header, sbyte[] cubeOrder);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_GetTextureBumpMapOrder", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PVRTexLibGetTextureBumpMapOrder(__IntPtr header, sbyte[] bumpOrder);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_GetTexturePixelFormat", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong PVRTexLibGetTexturePixelFormat(__IntPtr header);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_TextureHasPackedChannelData", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PVRTexLibTextureHasPackedChannelData(__IntPtr header);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_SetTextureChannelType", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PVRTexLibSetTextureChannelType(__IntPtr header, PVRTexLibVariableType type);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_SetTextureColourSpace", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PVRTexLibSetTextureColourSpace(__IntPtr header, PVRTexLibColourSpace colourSpace);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_SetTextureD3DFormat", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PVRTexLibSetTextureD3DFormat(__IntPtr header, uint d3dFormat);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_SetTextureDXGIFormat", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PVRTexLibSetTextureDXGIFormat(__IntPtr header, uint dxgiFormat);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_SetTextureOGLFormat", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PVRTexLibSetTextureOGLFormat(__IntPtr header, __IntPtr oglFormat);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_SetTextureOGLESFormat", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PVRTexLibSetTextureOGLESFormat(__IntPtr header, __IntPtr oglesFormat);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_SetTextureVulkanFormat", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PVRTexLibSetTextureVulkanFormat(__IntPtr header, uint vulkanFormat);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_SetTexturePixelFormat", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PVRTexLibSetTexturePixelFormat(__IntPtr header, ulong format);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_SetTextureWidth", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PVRTexLibSetTextureWidth(__IntPtr header, uint width);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_SetTextureHeight", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PVRTexLibSetTextureHeight(__IntPtr header, uint height);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_SetTextureDepth", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PVRTexLibSetTextureDepth(__IntPtr header, uint depth);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_SetTextureNumArrayMembers", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PVRTexLibSetTextureNumArrayMembers(__IntPtr header, uint numMembers);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_SetTextureNumMIPLevels", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PVRTexLibSetTextureNumMIPLevels(__IntPtr header, uint numMIPLevels);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_SetTextureNumFaces", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PVRTexLibSetTextureNumFaces(__IntPtr header, uint numFaces);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_SetTextureOrientation", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PVRTexLibSetTextureOrientation(__IntPtr header, __IntPtr orientation);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_SetTextureIsFileCompressed", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PVRTexLibSetTextureIsFileCompressed(__IntPtr header, bool isFileCompressed);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_SetTextureIsPreMultiplied", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PVRTexLibSetTextureIsPreMultiplied(__IntPtr header, bool isPreMultiplied);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_GetTextureBorder", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PVRTexLibGetTextureBorder(__IntPtr header, uint* borderWidth, uint* borderHeight, uint* borderDepth);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_GetMetaDataBlock", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PVRTexLibGetMetaDataBlock(__IntPtr header, uint devFOURCC, uint key, __IntPtr dataBlock, __IntPtr pfnAllocCallback);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_TextureHasMetaData", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PVRTexLibTextureHasMetaData(__IntPtr header, uint devFOURCC, uint key);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_SetTextureBumpMap", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PVRTexLibSetTextureBumpMap(__IntPtr header, float bumpScale, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string bumpOrder);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_SetTextureAtlas", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PVRTexLibSetTextureAtlas(__IntPtr header, float* atlasData, uint dataSize);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_SetTextureCubeMapOrder", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PVRTexLibSetTextureCubeMapOrder(__IntPtr header, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string cubeMapOrder);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_SetTextureBorder", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PVRTexLibSetTextureBorder(__IntPtr header, uint borderWidth, uint borderHeight, uint borderDepth);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_AddMetaData", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PVRTexLibAddMetaData(__IntPtr header, __IntPtr dataBlock);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_RemoveMetaData", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PVRTexLibRemoveMetaData(__IntPtr header, uint devFOURCC, uint key);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_CreateTexture", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr PVRTexLibCreateTexture(__IntPtr header, __IntPtr data);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_CopyTexture", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr PVRTexLibCopyTexture(__IntPtr texture);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_MoveTexture", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr PVRTexLibMoveTexture(__IntPtr texture);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_DestroyTexture", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PVRTexLibDestroyTexture(__IntPtr texture);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_CreateTextureFromFile", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr PVRTexLibCreateTextureFromFile([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string filePath);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_CreateTextureFromData", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr PVRTexLibCreateTextureFromData(__IntPtr data);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_GetTextureDataPtr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr PVRTexLibGetTextureDataPtr(__IntPtr texture, uint MIPLevel, uint arrayMember, uint faceNumber, uint ZSlice);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_GetTextureDataConstPtr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr PVRTexLibGetTextureDataConstPtr(__IntPtr texture, uint MIPLevel, uint arrayMember, uint faceNumber, uint ZSlice);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_GetTextureHeader", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr PVRTexLibGetTextureHeader(__IntPtr texture);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_GetTextureHeaderW", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr PVRTexLibGetTextureHeaderW(__IntPtr texture);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_AddPaddingMetaData", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PVRTexLibAddPaddingMetaData(__IntPtr texture, uint padding);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_SaveTextureToFile", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PVRTexLibSaveTextureToFile(__IntPtr texture, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string filePath);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_SaveTextureToMemory", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PVRTexLibSaveTextureToMemory(__IntPtr texture, PVRTexLibFileContainerType fileType, __IntPtr privateData, ulong* outSize, __IntPtr pfnRealloc);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_SaveSurfaceToImageFile", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PVRTexLibSaveSurfaceToImageFile(__IntPtr texture, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string filePath, uint MIPLevel, uint arrayMember, uint face, uint ZSlice);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_SaveTextureToLegacyPVRFile", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PVRTexLibSaveTextureToLegacyPVRFile(__IntPtr texture, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string filePath, PVRTexLibLegacyApi api);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_IsTextureMultiPart", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PVRTexLibIsTextureMultiPart(__IntPtr texture);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_GetTextureParts", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PVRTexLibGetTextureParts(__IntPtr inTexture, __IntPtr* outTextures, uint* count);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_ResizeTexture", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PVRTexLibResizeTexture(__IntPtr texture, uint newWidth, uint newHeight, uint newDepth, PVRTexLibResizeMode resizeMode);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_ResizeTextureCanvas", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PVRTexLibResizeTextureCanvas(__IntPtr texture, uint newWidth, uint newHeight, uint newDepth, int xOffset, int yOffset, int zOffset);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_RotateTexture", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PVRTexLibRotateTexture(__IntPtr texture, PVRTexLibAxis rotationAxis, bool forward);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_FlipTexture", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PVRTexLibFlipTexture(__IntPtr texture, PVRTexLibAxis flipDirection);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_BorderTexture", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PVRTexLibBorderTexture(__IntPtr texture, uint borderX, uint borderY, uint borderZ);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_PreMultiplyAlpha", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PVRTexLibPreMultiplyAlpha(__IntPtr texture);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_Bleed", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PVRTexLibBleed(__IntPtr texture);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_SetTextureChannels", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PVRTexLibSetTextureChannels(__IntPtr texture, uint numChannelSets, PVRTexLibChannelName* channels, uint* pValues);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_SetTextureChannelsFloat", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PVRTexLibSetTextureChannelsFloat(__IntPtr texture, uint numChannelSets, PVRTexLibChannelName* channels, float* pValues);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_CopyTextureChannels", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PVRTexLibCopyTextureChannels(__IntPtr textureDestination, __IntPtr textureSource, uint numChannelCopies, PVRTexLibChannelName* destinationChannels, PVRTexLibChannelName* sourceChannels);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_GenerateNormalMap", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PVRTexLibGenerateNormalMap(__IntPtr texture, float fScale, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string channelOrder);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_GenerateMIPMaps", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PVRTexLibGenerateMIPMaps(__IntPtr texture, PVRTexLibResizeMode filterMode, int mipMapsToDo);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_ColourMIPMaps", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PVRTexLibColourMIPMaps(__IntPtr texture);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_TranscodeTexture", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PVRTexLibTranscodeTexture(__IntPtr texture, __IntPtr transcoderOptions);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_Decompress", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PVRTexLibDecompress(__IntPtr texture, uint maxThreads);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_EquiRectToCubeMap", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PVRTexLibEquiRectToCubeMap(__IntPtr texture, PVRTexLibResizeMode filter);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_GenerateDiffuseIrradianceCubeMap", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PVRTexLibGenerateDiffuseIrradianceCubeMap(__IntPtr texture, uint sampleCount, uint mapSize);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_GeneratePreFilteredSpecularCubeMap", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PVRTexLibGeneratePreFilteredSpecularCubeMap(__IntPtr texture, uint sampleCount, uint mapSize, uint numMipLevelsToDiscard, bool zeroRoughnessIsExternal);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_MaxDifference", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PVRTexLibMaxDifference(__IntPtr textureLHS, __IntPtr textureRHS, uint MIPLevel, uint arrayMember, uint face, uint zSlice, __IntPtr metrics);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_MeanError", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PVRTexLibMeanError(__IntPtr textureLHS, __IntPtr textureRHS, uint MIPLevel, uint arrayMember, uint face, uint zSlice, __IntPtr metrics);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_MeanSquaredError", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PVRTexLibMeanSquaredError(__IntPtr textureLHS, __IntPtr textureRHS, uint MIPLevel, uint arrayMember, uint face, uint zSlice, __IntPtr metrics);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_RootMeanSquaredError", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PVRTexLibRootMeanSquaredError(__IntPtr textureLHS, __IntPtr textureRHS, uint MIPLevel, uint arrayMember, uint face, uint zSlice, __IntPtr metrics);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_StandardDeviation", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PVRTexLibStandardDeviation(__IntPtr textureLHS, __IntPtr textureRHS, uint MIPLevel, uint arrayMember, uint face, uint zSlice, __IntPtr metrics);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_PeakSignalToNoiseRatio", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PVRTexLibPeakSignalToNoiseRatio(__IntPtr textureLHS, __IntPtr textureRHS, uint MIPLevel, uint arrayMember, uint face, uint zSlice, __IntPtr metrics);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_ColourDiff", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PVRTexLibColourDiff(__IntPtr textureLHS, __IntPtr textureRHS, __IntPtr* textureResult, float multiplier, PVRTexLibColourDiffMode mode);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_ToleranceDiff", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PVRTexLibToleranceDiff(__IntPtr textureLHS, __IntPtr textureRHS, __IntPtr* textureResult, float tolerance);

            [SuppressUnmanagedCodeSecurity, DllImport("PVRTexLib.dll", EntryPoint = "PVRTexLib_BlendDiff", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PVRTexLibBlendDiff(__IntPtr textureLHS, __IntPtr textureRHS, __IntPtr* textureResult, float blendFactor);
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="result">
        /// <para>Default header attributes.</para>
        /// <para>***********************************************************************</para>
        /// </param>
        /// <remarks>Sets up default texture header parameters.</remarks>
        public static void PVRTexLibSetDefaultTextureHeaderParams(PVRHeaderCreateParams result)
        {
            var __arg0 = result is null ? __IntPtr.Zero : result.__Instance;
            __Internal.PVRTexLibSetDefaultTextureHeaderParams(__arg0);
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="attribs">The header attributes</param>
        /// <returns>
        /// <para>A handle to a new texture header.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>
        /// <para>Creates a new texture header using the supplied</para>
        /// <para>header parameters.</para>
        /// </remarks>
        public static __IntPtr PVRTexLibCreateTextureHeader(PVRHeaderCreateParams attribs)
        {
            var __arg0 = attribs is null ? __IntPtr.Zero : attribs.__Instance;
            var ___ret = __Internal.PVRTexLibCreateTextureHeader(__arg0);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">PVRTextureHeaderV3 structure to create from.</param>
        /// <param name="metaDataCount">Number of items in metaData, can be 0.</param>
        /// <param name="metaData">Array of meta data blocks, can be null.</param>
        /// <returns>
        /// <para>A handle to a new texture header.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>
        /// <para>Creates a new texture header from a PVRV3 structure.</para>
        /// <para>Optionally supply meta data.</para>
        /// </remarks>
        public static __IntPtr PVRTexLibCreateTextureHeaderFromHeader(PVRTextureHeaderV3 header, uint metaDataCount, PVRTexLibMetaDataBlock metaData)
        {
            var __arg0 = header is null ? __IntPtr.Zero : header.__Instance;
            var __arg2 = metaData is null ? __IntPtr.Zero : metaData.__Instance;
            var ___ret = __Internal.PVRTexLibCreateTextureHeaderFromHeader(__arg0, metaDataCount, __arg2);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <returns>
        /// <para>A handle to a new texture header.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>
        /// <para>Creates a new texture header by copying values from a</para>
        /// <para>previously allocated texture header.</para>
        /// </remarks>
        public static __IntPtr PVRTexLibCopyTextureHeader(__IntPtr header)
        {
            var ___ret = __Internal.PVRTexLibCopyTextureHeader(header);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">
        /// <para>Handle to a PVRTexLib_PVRTextureHeader.</para>
        /// <para>***********************************************************************</para>
        /// </param>
        /// <remarks>Free a previously allocated texture header.</remarks>
        public static void PVRTexLibDestroyTextureHeader(__IntPtr header)
        {
            __Internal.PVRTexLibDestroyTextureHeader(header);
        }

        /// <summary>************************************************************************</summary>
        /// <param name="width">Width of the texture in pixels</param>
        /// <param name="height">Height of the texture in pixels</param>
        /// <param name="depth">Number of Z layers</param>
        /// <param name="wMin">Minimum width of a texture level</param>
        /// <param name="hMin">Minimum height of a texture level</param>
        /// <param name="dMin">Minimum depth of a texture level</param>
        /// <param name="nBPP">Bits per pixel</param>
        /// <param name="bMIPMap">Create memory for MIP-map levels also?</param>
        /// <param name="pfnAllocCallback">Memory allocation callback function.</param>
        /// <returns>
        /// <para>Allocated texture memory. free()d by caller.</para>
        /// <para>************************************************************************</para>
        /// </returns>
        /// <remarks>
        /// <para>Low level texture creation function.</para>
        /// <para>Creates a PVRTextureHeaderV3 structure,</para>
        /// <para>including room for the specified texture, in memory.</para>
        /// </remarks>
        public static PVRTextureHeaderV3 PVRTexLibTextureCreateRaw(uint width, uint height, uint depth, uint wMin, uint hMin, uint dMin, uint nBPP, bool bMIPMap, Delegates.Func___IntPtr_ulong pfnAllocCallback)
        {
            var __arg8 = pfnAllocCallback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(pfnAllocCallback);
            var ___ret = __Internal.PVRTexLibTextureCreateRaw(width, height, depth, wMin, hMin, dMin, nBPP, bMIPMap, __arg8);
            var __result0 = PVRTextureHeaderV3.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>***************************************************************************</summary>
        /// <param name="pDst">Texture to place the tiled data</param>
        /// <param name="widthDst">Width of destination texture</param>
        /// <param name="heightDst">Height of destination texture</param>
        /// <param name="pSrc">Texture to tile</param>
        /// <param name="widthSrc">Width of source texture</param>
        /// <param name="heightSrc">Height of source texture</param>
        /// <param name="elementSize">Bytes per pixel</param>
        /// <param name="twiddled">
        /// <para>True if the data is twiddled</para>
        /// <para>***************************************************************************</para>
        /// </param>
        /// <remarks>
        /// <para>Low level texture creation function.</para>
        /// <para>Load blocks of data from pSrc into pDst.</para>
        /// </remarks>
        public static void PVRTexLibTextureLoadTiled(byte* pDst, uint widthDst, uint heightDst, byte* pSrc, uint widthSrc, uint heightSrc, uint elementSize, bool twiddled)
        {
            __Internal.PVRTexLibTextureLoadTiled(pDst, widthDst, heightDst, pSrc, widthSrc, heightSrc, elementSize, twiddled);
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <returns>
        /// <para>Number of bits per pixel.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>Gets the number of bits per pixel for the specified texture header.</remarks>
        public static uint PVRTexLibGetTextureBitsPerPixel(__IntPtr header)
        {
            var ___ret = __Internal.PVRTexLibGetTextureBitsPerPixel(header);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="u64PixelFormat">A PVR pixel format ID.</param>
        /// <returns>
        /// <para>Number of bits per pixel.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>Gets the number of bits per pixel for the specified pixel format.</remarks>
        public static uint PVRTexLibGetFormatBitsPerPixel(ulong u64PixelFormat)
        {
            var ___ret = __Internal.PVRTexLibGetFormatBitsPerPixel(u64PixelFormat);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <returns>
        /// <para>For uncompressed formats the number of channels between 1 and 4.</para>
        /// <para>For compressed formats 0</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>Gets the number of channels for the specified texture header.</remarks>
        public static uint PVRTexLibGetTextureChannelCount(__IntPtr header)
        {
            var ___ret = __Internal.PVRTexLibGetTextureChannelCount(header);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <returns>
        /// <para>PVRTexLibVariableType enum.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>Gets the channel type for the specified texture header.</remarks>
        public static PVRTexLibVariableType PVRTexLibGetTextureChannelType(__IntPtr header)
        {
            var ___ret = __Internal.PVRTexLibGetTextureChannelType(header);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <returns>
        /// <para>PVRTexLibColourSpace enum.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>Gets the colour space for the specified texture header.</remarks>
        public static PVRTexLibColourSpace PVRTexLibGetTextureColourSpace(__IntPtr header)
        {
            var ___ret = __Internal.PVRTexLibGetTextureColourSpace(header);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <param name="uiMipLevel">MIP level that user is interested in.</param>
        /// <returns>
        /// <para>Width of the specified MIP-Map level.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>
        /// <para>Gets the width of the user specified MIP-Map level for the</para>
        /// <para>texture</para>
        /// </remarks>
        public static uint PVRTexLibGetTextureWidth(__IntPtr header, uint mipLevel)
        {
            var ___ret = __Internal.PVRTexLibGetTextureWidth(header, mipLevel);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <param name="uiMipLevel">MIP level that user is interested in.</param>
        /// <returns>
        /// <para>Height of the specified MIP-Map level.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>
        /// <para>Gets the height of the user specified MIP-Map</para>
        /// <para>level for the texture</para>
        /// </remarks>
        public static uint PVRTexLibGetTextureHeight(__IntPtr header, uint mipLevel)
        {
            var ___ret = __Internal.PVRTexLibGetTextureHeight(header, mipLevel);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <param name="uiMipLevel">MIP level that user is interested in.</param>
        /// <returns>
        /// <para>Depth of the specified MIP-Map level.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>
        /// <para>Gets the depth of the user specified MIP-Map</para>
        /// <para>level for the texture</para>
        /// </remarks>
        public static uint PVRTexLibGetTextureDepth(__IntPtr header, uint mipLevel)
        {
            var ___ret = __Internal.PVRTexLibGetTextureDepth(header, mipLevel);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <param name="iMipLevel">
        /// <para>Specifies a MIP level to check,</para>
        /// <para>'PVRTEX_ALLMIPLEVELS' can be passed to get</para>
        /// <para>the size of all MIP levels.</para>
        /// </param>
        /// <param name="bAllSurfaces">
        /// <para>Size of all surfaces is calculated if true,</para>
        /// <para>only a single surface if false.</para>
        /// </param>
        /// <param name="bAllFaces">
        /// <para>Size of all faces is calculated if true,</para>
        /// <para>only a single face if false.</para>
        /// </param>
        /// <returns>
        /// <para>Size in PIXELS of the specified texture area.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>
        /// <para>Gets the size in PIXELS of the texture, given various input</para>
        /// <para>parameters.	User can retrieve the total size of either all</para>
        /// <para>surfaces or a single surface, all faces or a single face and</para>
        /// <para>all MIP-Maps or a single specified MIP level. All of these</para>
        /// </remarks>
        public static uint PVRTexLibGetTextureSize(__IntPtr header, int mipLevel, bool allSurfaces, bool allFaces)
        {
            var ___ret = __Internal.PVRTexLibGetTextureSize(header, mipLevel, allSurfaces, allFaces);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <param name="iMipLevel">
        /// <para>Specifies a mip level to check,</para>
        /// <para>'PVRTEX_ALLMIPLEVELS' can be passed to get</para>
        /// <para>the size of all MIP levels.</para>
        /// </param>
        /// <param name="bAllSurfaces">
        /// <para>Size of all surfaces is calculated if true,</para>
        /// <para>only a single surface if false.</para>
        /// </param>
        /// <param name="bAllFaces">
        /// <para>Size of all faces is calculated if true,</para>
        /// <para>only a single face if false.</para>
        /// </param>
        /// <returns>
        /// <para>Size in BYTES of the specified texture area.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>
        /// <para>Gets the size in BYTES of the texture, given various input</para>
        /// <para>parameters.	User can retrieve the size of either all</para>
        /// <para>surfaces or a single surface, all faces or a single face</para>
        /// <para>and all MIP-Maps or a single specified MIP level.</para>
        /// </remarks>
        public static ulong PVRTexLibGetTextureDataSize(__IntPtr header, int mipLevel, bool allSurfaces, bool allFaces)
        {
            var ___ret = __Internal.PVRTexLibGetTextureDataSize(header, mipLevel, allSurfaces, allFaces);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <param name="result">
        /// <para>Pointer to a PVRTexLib_Orientation structure.</para>
        /// <para>***********************************************************************</para>
        /// </param>
        /// <remarks>Gets the data orientation for this texture.</remarks>
        public static void PVRTexLibGetTextureOrientation(__IntPtr header, PVRTexLib_Orientation result)
        {
            var __arg1 = result is null ? __IntPtr.Zero : result.__Instance;
            __Internal.PVRTexLibGetTextureOrientation(header, __arg1);
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <param name="result">
        /// <para>Pointer to a PVRTexLib_OpenGLFormat structure.</para>
        /// <para>***********************************************************************</para>
        /// </param>
        /// <remarks>Gets the OpenGL equivalent format for this texture.</remarks>
        public static void PVRTexLibGetTextureOpenGLFormat(__IntPtr header, PVRTexLibOpenGLFormat result)
        {
            var __arg1 = result is null ? __IntPtr.Zero : result.__Instance;
            __Internal.PVRTexLibGetTextureOpenGLFormat(header, __arg1);
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <param name="result">
        /// <para>Pointer to a PVRTexLib_OpenGLESFormat structure.</para>
        /// <para>***********************************************************************</para>
        /// </param>
        /// <remarks>Gets the OpenGLES equivalent format for this texture.</remarks>
        public static void PVRTexLibGetTextureOpenGLESFormat(__IntPtr header, PVRTexLibOpenGLFormat result)
        {
            var __arg1 = result is null ? __IntPtr.Zero : result.__Instance;
            __Internal.PVRTexLibGetTextureOpenGLESFormat(header, __arg1);
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <returns>
        /// <para>A VkFormat enum value.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>Gets the Vulkan equivalent format for this texture.</remarks>
        public static uint PVRTexLibGetTextureVulkanFormat(__IntPtr header)
        {
            var ___ret = __Internal.PVRTexLibGetTextureVulkanFormat(header);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <returns>
        /// <para>A D3DFORMAT enum value.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>Gets the Direct3D equivalent format for this texture.</remarks>
        public static uint PVRTexLibGetTextureD3DFormat(__IntPtr header)
        {
            var ___ret = __Internal.PVRTexLibGetTextureD3DFormat(header);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <returns>
        /// <para>A DXGI_FORMAT enum value.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>Gets the DXGI equivalent format for this texture.</remarks>
        public static uint PVRTexLibGetTextureDXGIFormat(__IntPtr header)
        {
            var ___ret = __Internal.PVRTexLibGetTextureDXGIFormat(header);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <param name="minX">Returns the minimum width.</param>
        /// <param name="minY">Returns the minimum height.</param>
        /// <param name="minZ">
        /// <para>Returns the minimum depth.</para>
        /// <para>***********************************************************************</para>
        /// </param>
        /// <remarks>
        /// <para>Gets the minimum dimensions (x,y,z)</para>
        /// <para>for the textures pixel format.</para>
        /// </remarks>
        public static void PVRTexLibGetTextureFormatMinDims(__IntPtr header, ref uint minX, ref uint minY, ref uint minZ)
        {
            fixed (uint* __minX1 = &minX)
            {
                var __arg1 = __minX1;
                fixed (uint* __minY2 = &minY)
                {
                    var __arg2 = __minY2;
                    fixed (uint* __minZ3 = &minZ)
                    {
                        var __arg3 = __minZ3;
                        __Internal.PVRTexLibGetTextureFormatMinDims(header, __arg1, __arg2, __arg3);
                    }
                }
            }
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="u64PixelFormat">A PVR Pixel Format ID.</param>
        /// <param name="minX">Returns the minimum width.</param>
        /// <param name="minY">Returns the minimum height.</param>
        /// <param name="minZ">
        /// <para>Returns the minimum depth.</para>
        /// <para>***********************************************************************</para>
        /// </param>
        /// <remarks>
        /// <para>Gets the minimum dimensions (x,y,z)</para>
        /// <para>for the textures pixel format.</para>
        /// </remarks>
        public static void PVRTexLibGetPixelFormatMinDims(ulong ui64Format, ref uint minX, ref uint minY, ref uint minZ)
        {
            fixed (uint* __minX1 = &minX)
            {
                var __arg1 = __minX1;
                fixed (uint* __minY2 = &minY)
                {
                    var __arg2 = __minY2;
                    fixed (uint* __minZ3 = &minZ)
                    {
                        var __arg3 = __minZ3;
                        __Internal.PVRTexLibGetPixelFormatMinDims(ui64Format, __arg1, __arg2, __arg3);
                    }
                }
            }
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <returns>
        /// <para>Size, in bytes, of the meta data stored in the header.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>
        /// <para>Returns the total size of the meta data stored in the header.</para>
        /// <para>This includes the size of all information stored in all MetaDataBlocks.</para>
        /// </remarks>
        public static uint PVRTexLibGetTextureMetaDataSize(__IntPtr header)
        {
            var ___ret = __Internal.PVRTexLibGetTextureMetaDataSize(header);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <returns>
        /// <para>True if texture is premultiplied.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>
        /// <para>Returns whether or not the texture's colour has been</para>
        /// <para>pre-multiplied by the alpha values.</para>
        /// </remarks>
        public static bool PVRTexLibGetTextureIsPreMultiplied(__IntPtr header)
        {
            var ___ret = __Internal.PVRTexLibGetTextureIsPreMultiplied(header);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <returns>
        /// <para>True if it is file compressed.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>
        /// <para>Returns whether or not the texture is compressed using</para>
        /// <para>PVRTexLib's FILE compression - this is independent of</para>
        /// <para>any texture compression.</para>
        /// </remarks>
        public static bool PVRTexLibGetTextureIsFileCompressed(__IntPtr header)
        {
            var ___ret = __Internal.PVRTexLibGetTextureIsFileCompressed(header);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <returns>
        /// <para>True if it is a bump map.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>Returns whether or not the texture is a bump map.</remarks>
        public static bool PVRTexLibGetTextureIsBumpMap(__IntPtr header)
        {
            var ___ret = __Internal.PVRTexLibGetTextureIsBumpMap(header);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <returns>
        /// <para>Returns the bump map scale value as a float.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>
        /// <para>Gets the bump map scaling value for this texture.</para>
        /// <para>If the texture is not a bump map, 0.0f is returned. If the</para>
        /// <para>texture is a bump map but no meta data is stored to</para>
        /// <para>specify its scale, then 1.0f is returned.</para>
        /// </remarks>
        public static float PVRTexLibGetTextureBumpMapScale(__IntPtr header)
        {
            var ___ret = __Internal.PVRTexLibGetTextureBumpMapScale(header);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <returns>
        /// <para>The number of sub textures defined by meta data.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>
        /// <para>Works out the number of possible texture atlas members in</para>
        /// <para>the texture based on the width, height, depth and data size.</para>
        /// </remarks>
        public static uint PVRTexLibGetNumTextureAtlasMembers(__IntPtr header)
        {
            var ___ret = __Internal.PVRTexLibGetNumTextureAtlasMembers(header);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <param name="count">Number of floats in the returned data set.</param>
        /// <returns>
        /// <para>A pointer directly to the texture atlas data. NULL if</para>
        /// <para>the texture does not have atlas data.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>Returns a pointer to the texture atlas data.</remarks>
        public static float* PVRTexLibGetTextureAtlasData(__IntPtr header, ref uint count)
        {
            fixed (uint* __count1 = &count)
            {
                var __arg1 = __count1;
                var ___ret = __Internal.PVRTexLibGetTextureAtlasData(header, __arg1);
                return ___ret;
            }
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <returns>
        /// <para>Number of MIP-Map levels in this texture.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>Gets the number of MIP-Map levels stored in this texture.</remarks>
        public static uint PVRTexLibGetTextureNumMipMapLevels(__IntPtr header)
        {
            var ___ret = __Internal.PVRTexLibGetTextureNumMipMapLevels(header);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <returns>
        /// <para>Number of faces in this texture.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>Gets the number of faces stored in this texture.</remarks>
        public static uint PVRTexLibGetTextureNumFaces(__IntPtr header)
        {
            var ___ret = __Internal.PVRTexLibGetTextureNumFaces(header);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <returns>
        /// <para>Number of array members in this texture.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>Gets the number of array members stored in this texture.</remarks>
        public static uint PVRTexLibGetTextureNumArrayMembers(__IntPtr header)
        {
            var ___ret = __Internal.PVRTexLibGetTextureNumArrayMembers(header);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <param name="cubeOrder">
        /// <para>Null terminated cube map order string.</para>
        /// <para>***********************************************************************</para>
        /// </param>
        /// <remarks>
        /// <para>Gets the cube map face order.</para>
        /// <para>cubeOrder string will be in the form &quot;ZzXxYy&quot; with capitals</para>
        /// <para>representing positive and lower case letters representing</para>
        /// <para>negative. I.e. Z=Z-Positive, z=Z-Negative.</para>
        /// </remarks>
        public static void PVRTexLibGetTextureCubeMapOrder(__IntPtr header, sbyte[] cubeOrder)
        {
            if (cubeOrder == null || cubeOrder.Length != 7)
                throw new ArgumentOutOfRangeException("cubeOrder", "The dimensions of the provided array don't match the required size.");
            __Internal.PVRTexLibGetTextureCubeMapOrder(header, cubeOrder);
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <param name="Null">
        /// <para>terminated bump map order string relative to rgba.</para>
        /// <para>***********************************************************************</para>
        /// </param>
        /// <remarks>
        /// <para>Gets the bump map channel order relative to rgba.</para>
        /// <para>For	example, an RGB texture with bumps mapped to XYZ returns</para>
        /// <para>'xyz'. A BGR texture with bumps in the order ZYX will also</para>
        /// <para>return 'xyz' as the mapping is the same: R=X, G=Y, B=Z.</para>
        /// <para>If the letter 'h' is present in the string, it means that</para>
        /// <para>the height map has been stored here.</para>
        /// <para>Other characters are possible if the bump map was created</para>
        /// <para>manually, but PVRTexLib will ignore these characters. They</para>
        /// <para>are returned simply for completeness.</para>
        /// </remarks>
        public static void PVRTexLibGetTextureBumpMapOrder(__IntPtr header, sbyte[] bumpOrder)
        {
            if (bumpOrder == null || bumpOrder.Length != 5)
                throw new ArgumentOutOfRangeException("bumpOrder", "The dimensions of the provided array don't match the required size.");
            __Internal.PVRTexLibGetTextureBumpMapOrder(header, bumpOrder);
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <returns>
        /// <para>64-bit pixel type ID.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>Gets the 64-bit pixel type ID of the texture.</remarks>
        public static ulong PVRTexLibGetTexturePixelFormat(__IntPtr header)
        {
            var ___ret = __Internal.PVRTexLibGetTexturePixelFormat(header);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <returns>
        /// <para>True if the texture format is packed, false otherwise.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>
        /// <para>Checks whether the pixel format of the texture is packed.</para>
        /// <para>E.g. R5G6B5, R11G11B10, R4G4B4A4 etc.</para>
        /// </remarks>
        public static bool PVRTexLibTextureHasPackedChannelData(__IntPtr header)
        {
            var ___ret = __Internal.PVRTexLibTextureHasPackedChannelData(header);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <param name="type">
        /// <para>A PVRTexLibVariableType enum.</para>
        /// <para>***********************************************************************</para>
        /// </param>
        /// <remarks>Sets the variable type for the channels in this texture.</remarks>
        public static void PVRTexLibSetTextureChannelType(__IntPtr header, PVRTexLibVariableType type)
        {
            __Internal.PVRTexLibSetTextureChannelType(header, type);
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <param name="colourSpace">
        /// <para>A PVRTexLibColourSpace enum.</para>
        /// <para>***********************************************************************</para>
        /// </param>
        /// <remarks>Sets the colour space for this texture.</remarks>
        public static void PVRTexLibSetTextureColourSpace(__IntPtr header, PVRTexLibColourSpace colourSpace)
        {
            __Internal.PVRTexLibSetTextureColourSpace(header, colourSpace);
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <param name="d3dFormat">A D3DFORMAT enum.</param>
        /// <returns>
        /// <para>True if successful.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>
        /// <para>Sets the format of the texture to PVRTexLib's internal</para>
        /// <para>representation of the D3D format.</para>
        /// </remarks>
        public static bool PVRTexLibSetTextureD3DFormat(__IntPtr header, uint d3dFormat)
        {
            var ___ret = __Internal.PVRTexLibSetTextureD3DFormat(header, d3dFormat);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <param name="dxgiFormat">A DXGI_FORMAT enum.</param>
        /// <returns>
        /// <para>True if successful.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>
        /// <para>Sets the format of the texture to PVRTexLib's internal</para>
        /// <para>representation of the DXGI format.</para>
        /// </remarks>
        public static bool PVRTexLibSetTextureDXGIFormat(__IntPtr header, uint dxgiFormat)
        {
            var ___ret = __Internal.PVRTexLibSetTextureDXGIFormat(header, dxgiFormat);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <param name="oglFormat">The OpenGL format.</param>
        /// <returns>
        /// <para>True if successful.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>
        /// <para>Sets the format of the texture to PVRTexLib's internal</para>
        /// <para>representation of the OpenGL format.</para>
        /// </remarks>
        public static bool PVRTexLibSetTextureOGLFormat(__IntPtr header, PVRTexLibOpenGLFormat oglFormat)
        {
            var __arg1 = oglFormat is null ? __IntPtr.Zero : oglFormat.__Instance;
            var ___ret = __Internal.PVRTexLibSetTextureOGLFormat(header, __arg1);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <param name="oglesFormat">The OpenGLES format.</param>
        /// <returns>
        /// <para>True if successful.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>
        /// <para>Sets the format of the texture to PVRTexLib's internal</para>
        /// <para>representation of the OpenGLES format.</para>
        /// </remarks>
        public static bool PVRTexLibSetTextureOGLESFormat(__IntPtr header, PVRTexLibOpenGLFormat oglesFormat)
        {
            var __arg1 = oglesFormat is null ? __IntPtr.Zero : oglesFormat.__Instance;
            var ___ret = __Internal.PVRTexLibSetTextureOGLESFormat(header, __arg1);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <param name="vulkanFormat">A VkFormat enum.</param>
        /// <returns>
        /// <para>True if successful.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>
        /// <para>Sets the format of the texture to PVRTexLib's internal</para>
        /// <para>representation of the OpenGLES format.</para>
        /// </remarks>
        public static bool PVRTexLibSetTextureVulkanFormat(__IntPtr header, uint vulkanFormat)
        {
            var ___ret = __Internal.PVRTexLibSetTextureVulkanFormat(header, vulkanFormat);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <param name="format">
        /// <para>The format of the pixel.</para>
        /// <para>***********************************************************************</para>
        /// </param>
        /// <remarks>Sets the pixel format for this texture.</remarks>
        public static void PVRTexLibSetTexturePixelFormat(__IntPtr header, ulong format)
        {
            __Internal.PVRTexLibSetTexturePixelFormat(header, format);
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <param name="width">
        /// <para>The new width.</para>
        /// <para>***********************************************************************</para>
        /// </param>
        /// <remarks>Sets the texture width.</remarks>
        public static void PVRTexLibSetTextureWidth(__IntPtr header, uint width)
        {
            __Internal.PVRTexLibSetTextureWidth(header, width);
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <param name="height">
        /// <para>The new height.</para>
        /// <para>***********************************************************************</para>
        /// </param>
        /// <remarks>Sets the texture height.</remarks>
        public static void PVRTexLibSetTextureHeight(__IntPtr header, uint height)
        {
            __Internal.PVRTexLibSetTextureHeight(header, height);
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <param name="depth">
        /// <para>The new depth.</para>
        /// <para>***********************************************************************</para>
        /// </param>
        /// <remarks>Sets the texture depth.</remarks>
        public static void PVRTexLibSetTextureDepth(__IntPtr header, uint depth)
        {
            __Internal.PVRTexLibSetTextureDepth(header, depth);
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <param name="newNumMembers">
        /// <para>The new number of array members.</para>
        /// <para>***********************************************************************</para>
        /// </param>
        /// <remarks>Sets the number of array members in this texture.</remarks>
        public static void PVRTexLibSetTextureNumArrayMembers(__IntPtr header, uint numMembers)
        {
            __Internal.PVRTexLibSetTextureNumArrayMembers(header, numMembers);
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <param name="numMIPLevels">
        /// <para>New number of MIP-Map levels.</para>
        /// <para>***********************************************************************</para>
        /// </param>
        /// <remarks>Sets the number of MIP-Map levels in this texture.</remarks>
        public static void PVRTexLibSetTextureNumMIPLevels(__IntPtr header, uint numMIPLevels)
        {
            __Internal.PVRTexLibSetTextureNumMIPLevels(header, numMIPLevels);
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <param name="numFaces">
        /// <para>New number of faces for this texture.</para>
        /// <para>***********************************************************************</para>
        /// </param>
        /// <remarks>Sets the number of faces stored in this texture.</remarks>
        public static void PVRTexLibSetTextureNumFaces(__IntPtr header, uint numFaces)
        {
            __Internal.PVRTexLibSetTextureNumFaces(header, numFaces);
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <param name="orientation">
        /// <para>Pointer to a PVRTexLib_Orientation struct.</para>
        /// <para>***********************************************************************</para>
        /// </param>
        /// <remarks>Sets the data orientation for a given axis in this texture.</remarks>
        public static void PVRTexLibSetTextureOrientation(__IntPtr header, PVRTexLib_Orientation orientation)
        {
            var __arg1 = orientation is null ? __IntPtr.Zero : orientation.__Instance;
            __Internal.PVRTexLibSetTextureOrientation(header, __arg1);
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <param name="isFileCompressed">
        /// <para>Sets the file compression to true or false.</para>
        /// <para>***********************************************************************</para>
        /// </param>
        /// <remarks>
        /// <para>Sets whether or not the texture is compressed using</para>
        /// <para>PVRTexLib's FILE compression - this is independent of</para>
        /// <para>any texture compression. Currently unsupported.</para>
        /// </remarks>
        public static void PVRTexLibSetTextureIsFileCompressed(__IntPtr header, bool isFileCompressed)
        {
            __Internal.PVRTexLibSetTextureIsFileCompressed(header, isFileCompressed);
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <param name="isPreMultiplied">
        /// <para>Sets if texture is premultiplied.</para>
        /// <para>***********************************************************************</para>
        /// </param>
        /// <remarks>
        /// <para>Sets whether or not the texture's colour has been</para>
        /// <para>pre-multiplied by the alpha values.</para>
        /// </remarks>
        public static void PVRTexLibSetTextureIsPreMultiplied(__IntPtr header, bool isPreMultiplied)
        {
            __Internal.PVRTexLibSetTextureIsPreMultiplied(header, isPreMultiplied);
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <param name="borderWidth">Border width</param>
        /// <param name="borderHeight">Border height</param>
        /// <param name="borderDepth">
        /// <para>Border depth</para>
        /// <para>***********************************************************************</para>
        /// </param>
        /// <remarks>Obtains the border size in each dimension for this texture.</remarks>
        public static void PVRTexLibGetTextureBorder(__IntPtr header, ref uint borderWidth, ref uint borderHeight, ref uint borderDepth)
        {
            fixed (uint* __borderWidth1 = &borderWidth)
            {
                var __arg1 = __borderWidth1;
                fixed (uint* __borderHeight2 = &borderHeight)
                {
                    var __arg2 = __borderHeight2;
                    fixed (uint* __borderDepth3 = &borderDepth)
                    {
                        var __arg3 = __borderDepth3;
                        __Internal.PVRTexLibGetTextureBorder(header, __arg1, __arg2, __arg3);
                    }
                }
            }
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <param name="DevFOURCC">
        /// <para>Four character descriptor representing the</para>
        /// <para>creator of the meta data</para>
        /// </param>
        /// <param name="u32Key">Key value representing the type of meta data stored</param>
        /// <param name="dataBlock">returned meta block data</param>
        /// <param name="pfnAllocCallback">Memory allocation callback function.</param>
        /// <returns>
        /// <para>True if the meta data block was found.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>
        /// <para>Returns a copy of a block of meta data from the texture.</para>
        /// <para>If the meta data doesn't exist, a block with a data size</para>
        /// <para>of 0 will be returned.</para>
        /// </remarks>
        public static bool PVRTexLibGetMetaDataBlock(__IntPtr header, uint devFOURCC, uint key, PVRTexLibMetaDataBlock dataBlock, Delegates.Func___IntPtr_uint pfnAllocCallback)
        {
            var __arg3 = dataBlock is null ? __IntPtr.Zero : dataBlock.__Instance;
            var __arg4 = pfnAllocCallback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(pfnAllocCallback);
            var ___ret = __Internal.PVRTexLibGetMetaDataBlock(header, devFOURCC, key, __arg3, __arg4);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <param name="DevFOURCC">
        /// <para>Four character descriptor representing the</para>
        /// <para>creator of the meta data</para>
        /// </param>
        /// <param name="u32Key">Key value representing the type of meta data stored</param>
        /// <returns>
        /// <para>True if the specified meta data bock exists</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>
        /// <para>Returns whether or not the specified meta data exists as</para>
        /// <para>part of this texture header.</para>
        /// </remarks>
        public static bool PVRTexLibTextureHasMetaData(__IntPtr header, uint devFOURCC, uint key)
        {
            var ___ret = __Internal.PVRTexLibTextureHasMetaData(header, devFOURCC, key);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <param name="bumpScale">Floating point &quot;height&quot; value to scale the bump map.</param>
        /// <param name="bumpOrder">
        /// <para>Up to 4 character string, with values x,y,z,h in</para>
        /// <para>some combination. Not all values need to be present.</para>
        /// <para>Denotes channel order; x,y,z refer to the</para>
        /// <para>corresponding axes, h indicates presence of the</para>
        /// <para>original height map. It is possible to have only some</para>
        /// <para>of these values rather than all. For example if 'h'</para>
        /// <para>is present alone it will be considered a height map.</para>
        /// <para>The values should be presented in RGBA order, regardless</para>
        /// <para>of the texture format, so a zyxh order in a bgra texture</para>
        /// <para>should still be passed as 'xyzh'. Capitals are allowed.</para>
        /// <para>Any character stored here that is not one of x,y,z,h</para>
        /// <para>or a NULL character	will be ignored when PVRTexLib</para>
        /// <para>reads the data,	but will be preserved. This is useful</para>
        /// <para>if you wish to define a custom data channel for instance.</para>
        /// <para>In these instances PVRTexLib will assume it is simply</para>
        /// <para>colour data.</para>
        /// <para>***********************************************************************</para>
        /// </param>
        /// <remarks>Sets a texture's bump map data.</remarks>
        public static void PVRTexLibSetTextureBumpMap(__IntPtr header, float bumpScale, string bumpOrder)
        {
            __Internal.PVRTexLibSetTextureBumpMap(header, bumpScale, bumpOrder);
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <param name="atlasData">Pointer to an array of atlas data.</param>
        /// <param name="dataSize">
        /// <para>Number of floats in atlasData.</para>
        /// <para>***********************************************************************</para>
        /// </param>
        /// <remarks>
        /// <para>Sets the texture atlas coordinate meta data for later display.</para>
        /// <para>It is up to the user to make sure that this texture atlas</para>
        /// <para>data actually makes sense in the context of the header.</para>
        /// </remarks>
        public static void PVRTexLibSetTextureAtlas(__IntPtr header, ref float atlasData, uint dataSize)
        {
            fixed (float* __atlasData1 = &atlasData)
            {
                var __arg1 = __atlasData1;
                __Internal.PVRTexLibSetTextureAtlas(header, __arg1, dataSize);
            }
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <param name="cubeMapOrder">
        /// <para>Up to 6 character string, with values</para>
        /// <para>x,X,y,Y,z,Z in some combination. Not all</para>
        /// <para>values need to be present. Denotes face</para>
        /// <para>order; Capitals refer to positive axis</para>
        /// <para>positions and small letters refer to</para>
        /// <para>negative axis positions. E.g. x=X-Negative,</para>
        /// <para>X=X-Positive. It is possible to have only</para>
        /// <para>some of these values rather than all, as</para>
        /// <para>long as they are NULL terminated.</para>
        /// <para>NB: Values past the 6th character are not read.</para>
        /// <para>***********************************************************************</para>
        /// </param>
        /// <remarks>Sets the texture's face ordering.</remarks>
        public static void PVRTexLibSetTextureCubeMapOrder(__IntPtr header, string cubeMapOrder)
        {
            __Internal.PVRTexLibSetTextureCubeMapOrder(header, cubeMapOrder);
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <param name="borderWidth">Border width</param>
        /// <param name="borderHeight">Border height</param>
        /// <param name="borderDepth">
        /// <para>Border depth</para>
        /// <para>***********************************************************************</para>
        /// </param>
        /// <remarks>
        /// <para>Sets a texture's border size data. This value is subtracted</para>
        /// <para>from the current texture height/width/depth to get the valid</para>
        /// <para>texture data.</para>
        /// </remarks>
        public static void PVRTexLibSetTextureBorder(__IntPtr header, uint borderWidth, uint borderHeight, uint borderDepth)
        {
            __Internal.PVRTexLibSetTextureBorder(header, borderWidth, borderHeight, borderDepth);
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <param name="dataBlock">
        /// <para>Meta data block to be added.</para>
        /// <para>***********************************************************************</para>
        /// </param>
        /// <remarks>Adds an arbitrary piece of meta data.</remarks>
        public static void PVRTexLibAddMetaData(__IntPtr header, PVRTexLibMetaDataBlock dataBlock)
        {
            var __arg1 = dataBlock is null ? __IntPtr.Zero : dataBlock.__Instance;
            __Internal.PVRTexLibAddMetaData(header, __arg1);
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <param name="DevFOURCC">
        /// <para>Four character descriptor representing the</para>
        /// <para>creator of the meta data</para>
        /// </param>
        /// <param name="u32Key">
        /// <para>Key value representing the type of meta data stored.</para>
        /// <para>***********************************************************************</para>
        /// </param>
        /// <remarks>Removes a specified piece of meta data, if it exists.</remarks>
        public static void PVRTexLibRemoveMetaData(__IntPtr header, uint devFOURCC, uint key)
        {
            __Internal.PVRTexLibRemoveMetaData(header, devFOURCC, key);
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="header">A handle to a previously allocated PVRTexLib_PVRTextureHeader.</param>
        /// <param name="data">Texture data (may be NULL)</param>
        /// <returns>
        /// <para>A new texture handle.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>
        /// <para>Creates a new texture based on a texture header,</para>
        /// <para>and optionally copies the supplied texture data.</para>
        /// </remarks>
        public static __IntPtr PVRTexLibCreateTexture(__IntPtr header, __IntPtr data)
        {
            var ___ret = __Internal.PVRTexLibCreateTexture(header, data);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="texture">A handle to a PVRTexLib_PVRTexture to copy from.</param>
        /// <returns>
        /// <para>A new texture handle.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>Creates a copy of the supplied texture.</remarks>
        public static __IntPtr PVRTexLibCopyTexture(__IntPtr texture)
        {
            var ___ret = __Internal.PVRTexLibCopyTexture(texture);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="texture">A handle to a PVRTexLib_PVRTexture to move from.</param>
        /// <returns>
        /// <para>A new texture handle.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>
        /// <para>Creates a new texture, moving the contents of the</para>
        /// <para>supplied texture into the new texture.</para>
        /// </remarks>
        public static __IntPtr PVRTexLibMoveTexture(__IntPtr texture)
        {
            var ___ret = __Internal.PVRTexLibMoveTexture(texture);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="texture">
        /// <para>A handle to a previously allocated PVRTexLib_PVRTexture.</para>
        /// <para>***********************************************************************</para>
        /// </param>
        /// <remarks>Free a texture.</remarks>
        public static void PVRTexLibDestroyTexture(__IntPtr texture)
        {
            __Internal.PVRTexLibDestroyTexture(texture);
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="filePath">File path to the texture to load from.</param>
        /// <returns>
        /// <para>A new texture handle OR NULL on failure.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>
        /// <para>Creates a new texture from a file.</para>
        /// <para>Accepted file formats are: PVR, KTX, KTX2, ASTC, DDS, BASIS,</para>
        /// <para>PNG, JPEG, BMP, TGA, GIF, HDR, EXR, PSD, PPM, PGM and PIC</para>
        /// </remarks>
        public static __IntPtr PVRTexLibCreateTextureFromFile(string filePath)
        {
            var ___ret = __Internal.PVRTexLibCreateTextureFromFile(filePath);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="data">Pointer to texture data</param>
        /// <returns>
        /// <para>A new texture handle OR NULL on failure.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>
        /// <para>Creates a new texture from a pointer that includes a header</para>
        /// <para>structure, meta data and texture data as laid out in a file.</para>
        /// <para>This functionality is primarily for user-defined file loading.</para>
        /// <para>Header may be any version of pvr.</para>
        /// </remarks>
        public static __IntPtr PVRTexLibCreateTextureFromData(__IntPtr data)
        {
            var ___ret = __Internal.PVRTexLibCreateTextureFromData(data);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="texture">A handle to a previously allocated PVRTexLib_PVRTexture.</param>
        /// <param name="MIPLevel">Offset to MIP Map levels</param>
        /// <param name="arrayMember">Offset to array members</param>
        /// <param name="faceNumber">Offset to face numbers</param>
        /// <param name="ZSlice">Offset to Z slice (3D textures only)</param>
        /// <returns>
        /// <para>Pointer into the texture data OR NULL on failure.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>
        /// <para>Returns a pointer to the texture's data.</para>
        /// <para>The data offset is calculated using the parameters below.</para>
        /// </remarks>
        public static __IntPtr PVRTexLibGetTextureDataPtr(__IntPtr texture, uint MIPLevel, uint arrayMember, uint faceNumber, uint ZSlice)
        {
            var ___ret = __Internal.PVRTexLibGetTextureDataPtr(texture, MIPLevel, arrayMember, faceNumber, ZSlice);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="texture">A handle to a previously allocated PVRTexLib_PVRTexture.</param>
        /// <param name="MIPLevel">Offset to MIP Map levels</param>
        /// <param name="arrayMember">Offset to array members</param>
        /// <param name="faceNumber">Offset to face numbers</param>
        /// <param name="ZSlice">Offset to Z slice (3D textures only)</param>
        /// <returns>
        /// <para>Pointer into the texture data OR NULL on failure.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>
        /// <para>Returns a const pointer to the texture's data.</para>
        /// <para>The data offset is calculated using the parameters below.</para>
        /// </remarks>
        public static __IntPtr PVRTexLibGetTextureDataConstPtr(__IntPtr texture, uint MIPLevel, uint arrayMember, uint faceNumber, uint ZSlice)
        {
            var ___ret = __Internal.PVRTexLibGetTextureDataConstPtr(texture, MIPLevel, arrayMember, faceNumber, ZSlice);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="texture">A handle to a previously allocated PVRTexLib_PVRTexture.</param>
        /// <returns>
        /// <para>PVRTexLib_PVRTextureHeader handle.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>Returns a read only texture header.</remarks>
        public static __IntPtr PVRTexLibGetTextureHeader(__IntPtr texture)
        {
            var ___ret = __Internal.PVRTexLibGetTextureHeader(texture);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="texture">A handle to a previously allocated PVRTexLib_PVRTexture.</param>
        /// <returns>
        /// <para>PVRTexLib_PVRTextureHeader handle.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>Gets a write-able handle to the texture header.</remarks>
        public static __IntPtr PVRTexLibGetTextureHeaderW(__IntPtr texture)
        {
            var ___ret = __Internal.PVRTexLibGetTextureHeaderW(texture);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="texture">A handle to a previously allocated PVRTexLib_PVRTexture.</param>
        /// <param name="padding">
        /// <para>Padding boundary value</para>
        /// <para>***********************************************************************</para>
        /// </param>
        /// <remarks>
        /// <para>Pads the texture data to a boundary value equal to &quot;padding&quot;.</para>
        /// <para>For example setting padding=8 will align the start of the</para>
        /// <para>texture data to an 8 byte boundary.</para>
        /// <para>NB: This should be called immediately before saving as</para>
        /// <para>the value is worked out based on the current meta data size.</para>
        /// </remarks>
        public static void PVRTexLibAddPaddingMetaData(__IntPtr texture, uint padding)
        {
            __Internal.PVRTexLibAddPaddingMetaData(texture, padding);
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="texture">A handle to a previously allocated PVRTexLib_PVRTexture.</param>
        /// <param name="filepath">File path to write to</param>
        /// <returns>
        /// <para>True if the method succeeds.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>
        /// <para>Saves the texture to a given file path.</para>
        /// <para>File type will be determined by the extension present in the string.</para>
        /// <para>Valid extensions are: PVR, KTX, KTX2, ASTC, DDS, BASIS and h</para>
        /// <para>If no extension is present the PVR format will be selected.</para>
        /// <para>Unsupported formats will result in failure.</para>
        /// <para>ASTC files only support ASTC texture formats.</para>
        /// <para>BASIS files only support Basis Universal texture formats.</para>
        /// </remarks>
        public static bool PVRTexLibSaveTextureToFile(__IntPtr texture, string filePath)
        {
            var ___ret = __Internal.PVRTexLibSaveTextureToFile(texture, filePath);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="texture">A handle to a previously allocated PVRTexLib_PVRTexture.</param>
        /// <param name="fileType">File container type to wrap the texture data with.</param>
        /// <param name="privateData">
        /// <para>Pointer to a user supplied allocation context.</para>
        /// <para>PVRTexLib will pass this into pfnRealloc when a [re]allocation</para>
        /// <para>is required.</para>
        /// </param>
        /// <param name="outSize">Size, in bytes, of the resulting 'file'/data.</param>
        /// <param name="pfnRealloc">
        /// <para>Callback function to reallocate memory on-demand.</para>
        /// <para>Return NULL to indicate allocation failure.</para>
        /// </param>
        /// <returns>
        /// <para>True if the method succeeds.</para>
        /// <para>N.B This function may allocate even if it fails.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>
        /// <para>Similar to PVRTexLib_SaveTextureToFile, but redirects</para>
        /// <para>the data to a memory buffer instead of a file.</para>
        /// <para>Caller is responsible for de-allocating memory.</para>
        /// </remarks>
        public static bool PVRTexLibSaveTextureToMemory(__IntPtr texture, PVRTexLibFileContainerType fileType, __IntPtr privateData, ref ulong outSize, Delegates.Func_bytePtr___IntPtr_ulong pfnRealloc)
        {
            fixed (ulong* __outSize3 = &outSize)
            {
                var __arg3 = __outSize3;
                var __arg4 = pfnRealloc == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(pfnRealloc);
                var ___ret = __Internal.PVRTexLibSaveTextureToMemory(texture, fileType, privateData, __arg3, __arg4);
                return ___ret;
            }
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="texture">A handle to a previously allocated PVRTexLib_PVRTexture.</param>
        /// <param name="filepath">Path to write the image file.</param>
        /// <param name="MIPLevel">Mip level.</param>
        /// <param name="arrayMember">Array index.</param>
        /// <param name="face">Face index.</param>
        /// <param name="ZSlice">Z index.</param>
        /// <returns>
        /// <para>True if the method succeeds.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>
        /// <para>Writes out a single surface to a given image file.</para>
        /// <para>File type is determined by the extension present in the filepath string.</para>
        /// <para>Supported file types are PNG, JPG, BMP, TGA and HDR.</para>
        /// <para>If no extension is present then the PNG format will be selected.</para>
        /// <para>Unsupported formats will result in failure.</para>
        /// </remarks>
        public static bool PVRTexLibSaveSurfaceToImageFile(__IntPtr texture, string filePath, uint MIPLevel, uint arrayMember, uint face, uint ZSlice)
        {
            var ___ret = __Internal.PVRTexLibSaveSurfaceToImageFile(texture, filePath, MIPLevel, arrayMember, face, ZSlice);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="texture">A handle to a previously allocated PVRTexLib_PVRTexture.</param>
        /// <param name="filepath">File path to write to</param>
        /// <param name="api">Target API</param>
        /// <returns>
        /// <para>True if the method succeeds.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>
        /// <para>Saves the texture to a file, stripping any</para>
        /// <para>extensions specified and appending .pvr. This function is</para>
        /// <para>for legacy support only and saves out to PVR Version 2 file.</para>
        /// <para>The target api must be specified in order to save to this format.</para>
        /// </remarks>
        public static bool PVRTexLibSaveTextureToLegacyPVRFile(__IntPtr texture, string filePath, PVRTexLibLegacyApi api)
        {
            var ___ret = __Internal.PVRTexLibSaveTextureToLegacyPVRFile(texture, filePath, api);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="texture">A handle to a previously allocated PVRTexLib_PVRTexture.</param>
        /// <returns>
        /// <para>True if texture contains more than one PVRTexLib_PVRTexture.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>
        /// <para>Queries the texture object to determine if there are multiple</para>
        /// <para>texture objects associated with the handle. This may be the</para>
        /// <para>case after loading certain file types such as EXR, since EXR</para>
        /// <para>files may contain several images/layers with unique pixel formats.</para>
        /// <para>In these cases PVRTexLib will group all images with the same</para>
        /// <para>pixel format into a single PVRTexLib_PVRTexture object, where</para>
        /// <para>each PVRTexLib_PVRTexture can contain multiple array surfaces.</para>
        /// </remarks>
        public static bool PVRTexLibIsTextureMultiPart(__IntPtr texture)
        {
            var ___ret = __Internal.PVRTexLibIsTextureMultiPart(texture);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="texture">A handle to a previously allocated PVRTexLib_PVRTexture.</param>
        /// <param name="outTextures">
        /// <para>Array of PVRTexLib_PVRTexture handles to be populated.</para>
        /// <para>All returned handles are independent of each other and 'inTexture'.</para>
        /// </param>
        /// <param name="count">
        /// <para>The number of parts held by inTexture</para>
        /// <para>***********************************************************************</para>
        /// </param>
        /// <remarks>
        /// <para>Retrieves (and moves ownership of) the PVRTexLib_PVRTexture handles</para>
        /// <para>stored within a multi-part texture and stores them in 'outTextures'.</para>
        /// <para>Call this function with 'outTextures' == NULL to populate count</para>
        /// <para>and then allocate an appropriately sized array. Handles returned</para>
        /// <para>in 'outTextures' should be de-allocated as normal via</para>
        /// <para>PVRTexLib_DestroyTexture. After calling this function, subsequent</para>
        /// <para>calls to PVRTexLib_IsTextureMultiPart on the same handle will</para>
        /// <para>return false.</para>
        /// </remarks>
        public static void PVRTexLibGetTextureParts(__IntPtr inTexture, __IntPtr* outTextures, ref uint count)
        {
            fixed (uint* __count2 = &count)
            {
                var __arg2 = __count2;
                __Internal.PVRTexLibGetTextureParts(inTexture, outTextures, __arg2);
            }
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="texture">A handle to a previously allocated PVRTexLib_PVRTexture.</param>
        /// <param name="newWidth">New width</param>
        /// <param name="newHeight">New height</param>
        /// <param name="newDepth">New depth</param>
        /// <param name="resizeMode">Filtering mode</param>
        /// <returns>
        /// <para>True if the method succeeds.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>Resizes the texture to new specified dimensions.</remarks>
        public static bool PVRTexLibResizeTexture(__IntPtr texture, uint newWidth, uint newHeight, uint newDepth, PVRTexLibResizeMode resizeMode)
        {
            var ___ret = __Internal.PVRTexLibResizeTexture(texture, newWidth, newHeight, newDepth, resizeMode);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="texture">A handle to a previously allocated PVRTexLib_PVRTexture.</param>
        /// <param name="u32NewWidth">New width</param>
        /// <param name="u32NewHeight">New height</param>
        /// <param name="u32NewDepth">New depth</param>
        /// <param name="i32XOffset">X Offset value from the top left corner</param>
        /// <param name="i32YOffset">Y Offset value from the top left corner</param>
        /// <param name="i32ZOffset">Z Offset value from the top left corner</param>
        /// <returns>
        /// <para>True if the method succeeds.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>
        /// <para>Resizes the canvas of a texture to new specified dimensions.</para>
        /// <para>Offset area is filled with transparent black colour.</para>
        /// </remarks>
        public static bool PVRTexLibResizeTextureCanvas(__IntPtr texture, uint newWidth, uint newHeight, uint newDepth, int xOffset, int yOffset, int zOffset)
        {
            var ___ret = __Internal.PVRTexLibResizeTextureCanvas(texture, newWidth, newHeight, newDepth, xOffset, yOffset, zOffset);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="texture">A handle to a previously allocated PVRTexLib_PVRTexture.</param>
        /// <param name="rotationAxis">Rotation axis</param>
        /// <param name="forward">Direction of rotation; true = clockwise, false = anti-clockwise</param>
        /// <returns>
        /// <para>True if the method succeeds or not.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>Rotates a texture by 90 degrees around the given axis.</remarks>
        public static bool PVRTexLibRotateTexture(__IntPtr texture, PVRTexLibAxis rotationAxis, bool forward)
        {
            var ___ret = __Internal.PVRTexLibRotateTexture(texture, rotationAxis, forward);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="texture">A handle to a previously allocated PVRTexLib_PVRTexture.</param>
        /// <param name="flipDirection">Flip direction</param>
        /// <returns>
        /// <para>True if the method succeeds.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>Flips a texture on a given axis.</remarks>
        public static bool PVRTexLibFlipTexture(__IntPtr texture, PVRTexLibAxis flipDirection)
        {
            var ___ret = __Internal.PVRTexLibFlipTexture(texture, flipDirection);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="texture">A handle to a previously allocated PVRTexLib_PVRTexture.</param>
        /// <param name="borderX">X border</param>
        /// <param name="borderY">Y border</param>
        /// <param name="borderZ">Z border</param>
        /// <returns>
        /// <para>True if the method succeeds.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>Adds a user specified border to the texture.</remarks>
        public static bool PVRTexLibBorderTexture(__IntPtr texture, uint borderX, uint borderY, uint borderZ)
        {
            var ___ret = __Internal.PVRTexLibBorderTexture(texture, borderX, borderY, borderZ);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="texture">A handle to a previously allocated PVRTexLib_PVRTexture.</param>
        /// <returns>
        /// <para>True if the method succeeds.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>Pre-multiplies a texture's colours by its alpha values.</remarks>
        public static bool PVRTexLibPreMultiplyAlpha(__IntPtr texture)
        {
            var ___ret = __Internal.PVRTexLibPreMultiplyAlpha(texture);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="texture">A handle to a previously allocated PVRTexLib_PVRTexture.</param>
        /// <returns>
        /// <para>True if the method succeeds.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>Allows a texture's colours to run into any fully transparent areas.</remarks>
        public static bool PVRTexLibBleed(__IntPtr texture)
        {
            var ___ret = __Internal.PVRTexLibBleed(texture);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="texture">A handle to a previously allocated PVRTexLib_PVRTexture.</param>
        /// <param name="numChannelSets">Number of channels to set</param>
        /// <param name="channels">Channels to set</param>
        /// <param name="pValues">uint32 values to set channels to</param>
        /// <returns>
        /// <para>True if the method succeeds.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>Sets the specified number of channels to values specified in pValues.</remarks>
        public static bool PVRTexLibSetTextureChannels(__IntPtr texture, uint numChannelSets, ref PVRTexLibChannelName channels, ref uint pValues)
        {
            fixed (PVRTexLibChannelName* __channels2 = &channels)
            {
                var __arg2 = __channels2;
                fixed (uint* __pValues3 = &pValues)
                {
                    var __arg3 = __pValues3;
                    var ___ret = __Internal.PVRTexLibSetTextureChannels(texture, numChannelSets, __arg2, __arg3);
                    return ___ret;
                }
            }
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="texture">A handle to a previously allocated PVRTexLib_PVRTexture.</param>
        /// <param name="numChannelSets">Number of channels to set</param>
        /// <param name="channels">Channels to set</param>
        /// <param name="pValues">float values to set channels to</param>
        /// <returns>
        /// <para>True if the method succeeds.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>Sets the specified number of channels to values specified in float pValues.</remarks>
        public static bool PVRTexLibSetTextureChannelsFloat(__IntPtr texture, uint numChannelSets, ref PVRTexLibChannelName channels, ref float pValues)
        {
            fixed (PVRTexLibChannelName* __channels2 = &channels)
            {
                var __arg2 = __channels2;
                fixed (float* __pValues3 = &pValues)
                {
                    var __arg3 = __pValues3;
                    var ___ret = __Internal.PVRTexLibSetTextureChannelsFloat(texture, numChannelSets, __arg2, __arg3);
                    return ___ret;
                }
            }
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="textureDestination">A handle to a previously allocated PVRTexLib_PVRTexture.</param>
        /// <param name="textureSource">A handle to a previously allocated PVRTexLib_PVRTexture.</param>
        /// <param name="uiNumChannelCopies">Number of channels to copy</param>
        /// <param name="destinationChannels">Channels to set</param>
        /// <param name="sourceChannels">Source channels to copy from</param>
        /// <returns>
        /// <para>True if the method succeeds.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>
        /// <para>Copies the specified channels from textureSource</para>
        /// <para>into textureDestination. textureSource is not modified so it</para>
        /// <para>is possible to use the same texture as both input and output.</para>
        /// <para>When using the same texture as source and destination, channels</para>
        /// <para>are preserved between swaps e.g. copying Red to Green and then</para>
        /// <para>Green to Red will result in the two channels trading places</para>
        /// <para>correctly. Channels in eChannels are set to the value of the channels</para>
        /// <para>in eChannelSource.</para>
        /// </remarks>
        public static bool PVRTexLibCopyTextureChannels(__IntPtr textureDestination, __IntPtr textureSource, uint numChannelCopies, ref PVRTexLibChannelName destinationChannels, ref PVRTexLibChannelName sourceChannels)
        {
            fixed (PVRTexLibChannelName* __destinationChannels3 = &destinationChannels)
            {
                var __arg3 = __destinationChannels3;
                fixed (PVRTexLibChannelName* __sourceChannels4 = &sourceChannels)
                {
                    var __arg4 = __sourceChannels4;
                    var ___ret = __Internal.PVRTexLibCopyTextureChannels(textureDestination, textureSource, numChannelCopies, __arg3, __arg4);
                    return ___ret;
                }
            }
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="texture">A handle to a previously allocated PVRTexLib_PVRTexture.</param>
        /// <param name="fScale">Scale factor</param>
        /// <param name="channelOrder">Channel order</param>
        /// <returns>
        /// <para>True if the method succeeds.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>
        /// <para>Generates a Normal Map from a given height map.</para>
        /// <para>Assumes the red channel has the height values.</para>
        /// <para>By default outputs to red/green/blue = x/y/z,</para>
        /// <para>this can be overridden by specifying a channel</para>
        /// <para>order in channelOrder. The channels specified</para>
        /// <para>will output to red/green/blue/alpha in that order.</para>
        /// <para>So &quot;xyzh&quot; maps x to red, y to green, z to blue</para>
        /// <para>and h to alpha. 'h' is used to specify that the</para>
        /// <para>original height map data should be preserved in</para>
        /// <para>the given channel.</para>
        /// </remarks>
        public static bool PVRTexLibGenerateNormalMap(__IntPtr texture, float fScale, string channelOrder)
        {
            var ___ret = __Internal.PVRTexLibGenerateNormalMap(texture, fScale, channelOrder);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="texture">A handle to a previously allocated PVRTexLib_PVRTexture.</param>
        /// <param name="filterMode">Filter mode</param>
        /// <param name="mipMapsToDo">
        /// <para>Number of levels of MIPMap chain to create.</para>
        /// <para>Use PVRTEX_ALLMIPLEVELS to create a full mip chain.</para>
        /// </param>
        /// <returns>
        /// <para>True if the method succeeds.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>Generates MIPMap chain for a texture.</remarks>
        public static bool PVRTexLibGenerateMIPMaps(__IntPtr texture, PVRTexLibResizeMode filterMode, int mipMapsToDo)
        {
            var ___ret = __Internal.PVRTexLibGenerateMIPMaps(texture, filterMode, mipMapsToDo);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="texture">A handle to a previously allocated PVRTexLib_PVRTexture.</param>
        /// <returns>
        /// <para>True if the method succeeds.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>
        /// <para>Colours a texture's MIPMap levels with different colours</para>
        /// <para>for debugging purposes. MIP levels are coloured in the</para>
        /// <para>following repeating pattern: Red, Green, Blue, Cyan,</para>
        /// <para>Magenta and Yellow</para>
        /// </remarks>
        public static bool PVRTexLibColourMIPMaps(__IntPtr texture)
        {
            var ___ret = __Internal.PVRTexLibColourMIPMaps(texture);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="texture">A handle to a previously allocated PVRTexLib_PVRTexture.</param>
        /// <param name="transcoderOptions">struct containing transcoder options.</param>
        /// <returns>
        /// <para>True if the method succeeds.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>Transcodes a texture from its original format into the specified format.</remarks>
        public static bool PVRTexLibTranscodeTexture(__IntPtr texture, PVRTexLibTranscoderOptions transcoderOptions)
        {
            if (ReferenceEquals(transcoderOptions, null))
                throw new global::System.ArgumentNullException("transcoderOptions", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = transcoderOptions.__Instance;
            var ___ret = __Internal.PVRTexLibTranscodeTexture(texture, __arg1);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="texture">A handle to a previously allocated PVRTexLib_PVRTexture.</param>
        /// <param name="maxThreads">
        /// <para>The maximum number of threads to use for decompression,</para>
        /// <para>if set to 0 PVRTexLib will use all available cores.</para>
        /// </param>
        /// <returns>
        /// <para>True if the method succeeds.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>
        /// <para>A convenience function to decompresses a texture into the most</para>
        /// <para>appropriate format based on the textures 'compressed' format,</para>
        /// <para>for example a PVRTC compressed texture may decompress to RGB888</para>
        /// <para>or RGBA8888. This function may also be used	to 'decompress'</para>
        /// <para>packed formats into something easier to manipulate for example</para>
        /// <para>RGB565 will be decompressed to RGB888.</para>
        /// </remarks>
        public static bool PVRTexLibDecompress(__IntPtr texture, uint maxThreads)
        {
            var ___ret = __Internal.PVRTexLibDecompress(texture, maxThreads);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="texture">A handle to a previously allocated PVRTexLib_PVRTexture.</param>
        /// <param name="filterMode">Filtering mode to apply when sampling the source texture.</param>
        /// <returns>
        /// <para>True if the method succeeds.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>
        /// <para>Creates a cubemap with six faces from an equirectangular</para>
        /// <para>projected texture. The input must have an aspect ratio of 2:1,</para>
        /// <para>i.e. the width must be exactly twice the height.</para>
        /// </remarks>
        public static bool PVRTexLibEquiRectToCubeMap(__IntPtr texture, PVRTexLibResizeMode filter)
        {
            var ___ret = __Internal.PVRTexLibEquiRectToCubeMap(texture, filter);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="texture">A handle to a previously allocated PVRTexLib_PVRTexture.</param>
        /// <param name="sampleCount">
        /// <para>The number of samples to use when generating</para>
        /// <para>the diffuse map.</para>
        /// </param>
        /// <param name="mapSize">Output dimensions, in pixels.</param>
        /// <returns>
        /// <para>True if the method succeeds.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>
        /// <para>Generates a mipmapped diffuse irradiance texture from a cubemap</para>
        /// <para>environment map, to be used	primarily with physically based</para>
        /// <para>rendering (PBR) techniques.</para>
        /// <para>The input must be a cubemap, the width must equal height,</para>
        /// <para>and the depth must equal 1.</para>
        /// </remarks>
        public static bool PVRTexLibGenerateDiffuseIrradianceCubeMap(__IntPtr texture, uint sampleCount, uint mapSize)
        {
            var ___ret = __Internal.PVRTexLibGenerateDiffuseIrradianceCubeMap(texture, sampleCount, mapSize);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="texture">A handle to a previously allocated PVRTexLib_PVRTexture.</param>
        /// <param name="sampleCount">
        /// <para>The number of samples to use when generating</para>
        /// <para>the specular map.</para>
        /// </param>
        /// <param name="mapSize">Output dimensions, in pixels.</param>
        /// <param name="numMipLevelsToDiscard">
        /// <para>The number of Mip levels to be discarded</para>
        /// <para>from the bottom of the Mip chain.</para>
        /// </param>
        /// <param name="zeroRoughnessIsExternal">
        /// <para>False to include a roughness of zero</para>
        /// <para>when generating the prefiltered environment map.</para>
        /// <para>True to omit a rougness of zero, implying that the user</para>
        /// <para>will supply roughness zero from the environment texture.</para>
        /// </param>
        /// <returns>
        /// <para>True if the method succeeds.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>
        /// <para>Generates a prefiltered specular irradiance texture from a</para>
        /// <para>cubemap environment map, to be used	primarily with physically</para>
        /// <para>based rendering (PBR) techniques.</para>
        /// <para>Each Mip level of the specular map is blurred by a roughness</para>
        /// <para>value between 0 and 1.</para>
        /// <para>The input must be a cubemap, the width must equal height,</para>
        /// <para>and the depth must equal 1.</para>
        /// </remarks>
        public static bool PVRTexLibGeneratePreFilteredSpecularCubeMap(__IntPtr texture, uint sampleCount, uint mapSize, uint numMipLevelsToDiscard, bool zeroRoughnessIsExternal)
        {
            var ___ret = __Internal.PVRTexLibGeneratePreFilteredSpecularCubeMap(texture, sampleCount, mapSize, numMipLevelsToDiscard, zeroRoughnessIsExternal);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="textureLHS">A handle to a previously allocated PVRTexLib_PVRTexture.</param>
        /// <param name="textureRHS">A handle to a previously allocated PVRTexLib_PVRTexture.</param>
        /// <param name="MIPLevel">The Mip to compare.</param>
        /// <param name="arrayMember">The array to compare.</param>
        /// <param name="face">The face to compare.</param>
        /// <param name="zSlice">The Z slice to compare.</param>
        /// <param name="metrics">Structure containing the resulting values.</param>
        /// <returns>
        /// <para>True if the method succeeds.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>
        /// <para>Computes the maximum difference between two given input textures.</para>
        /// <para>The MIPLevel, arrayMember, face and zSlice values determine which</para>
        /// <para>surfaces are compared. NB: MIPLevel, arrayMember, face and zSlice</para>
        /// <para>should be valid in both input textures. Both textures must have the</para>
        /// <para>same dimensions. The function will only compare common channels i.e.</para>
        /// <para>if 'LHS' has RGB while 'RHS' has RGBA channels, then only the RGB</para>
        /// <para>channels will be compared.</para>
        /// </remarks>
        public static bool PVRTexLibMaxDifference(__IntPtr textureLHS, __IntPtr textureRHS, uint MIPLevel, uint arrayMember, uint face, uint zSlice, PVRTexLibErrorMetrics metrics)
        {
            var __arg6 = metrics is null ? __IntPtr.Zero : metrics.__Instance;
            var ___ret = __Internal.PVRTexLibMaxDifference(textureLHS, textureRHS, MIPLevel, arrayMember, face, zSlice, __arg6);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="textureLHS">A handle to a previously allocated PVRTexLib_PVRTexture.</param>
        /// <param name="textureRHS">A handle to a previously allocated PVRTexLib_PVRTexture.</param>
        /// <param name="MIPLevel">The Mip to compare.</param>
        /// <param name="arrayMember">The array to compare.</param>
        /// <param name="face">The face to compare.</param>
        /// <param name="zSlice">The Z slice to compare.</param>
        /// <param name="metrics">Structure containing the resulting values.</param>
        /// <returns>
        /// <para>True if the method succeeds.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>
        /// <para>Computes the mean error between two given input textures.</para>
        /// <para>The MIPLevel, arrayMember, face and zSlice values determine which</para>
        /// <para>surfaces are compared. NB: MIPLevel, arrayMember, face and zSlice</para>
        /// <para>should be valid in both input textures. Both textures must have the</para>
        /// <para>same dimensions. The function will only compare common channels i.e.</para>
        /// <para>if 'LHS' has RGB while 'RHS' has RGBA channels, then only the RGB</para>
        /// <para>channels will be compared.</para>
        /// </remarks>
        public static bool PVRTexLibMeanError(__IntPtr textureLHS, __IntPtr textureRHS, uint MIPLevel, uint arrayMember, uint face, uint zSlice, PVRTexLibErrorMetrics metrics)
        {
            var __arg6 = metrics is null ? __IntPtr.Zero : metrics.__Instance;
            var ___ret = __Internal.PVRTexLibMeanError(textureLHS, textureRHS, MIPLevel, arrayMember, face, zSlice, __arg6);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="textureLHS">A handle to a previously allocated PVRTexLib_PVRTexture.</param>
        /// <param name="textureRHS">A handle to a previously allocated PVRTexLib_PVRTexture.</param>
        /// <param name="MIPLevel">The Mip to compare.</param>
        /// <param name="arrayMember">The array to compare.</param>
        /// <param name="face">The face to compare.</param>
        /// <param name="zSlice">The Z slice to compare.</param>
        /// <param name="metrics">Structure containing the resulting values.</param>
        /// <returns>
        /// <para>True if the method succeeds.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>
        /// <para>Computes the mean squared error (MSE) between two given input textures.</para>
        /// <para>The MIPLevel, arrayMember, face and zSlice values determine which</para>
        /// <para>surfaces are compared. NB: MIPLevel, arrayMember, face and zSlice</para>
        /// <para>should be valid in both input textures. Both textures must have the</para>
        /// <para>same dimensions. The function will only compare common channels i.e.</para>
        /// <para>if 'LHS' has RGB while 'RHS' has RGBA channels, then only the RGB</para>
        /// <para>channels will be compared.</para>
        /// </remarks>
        public static bool PVRTexLibMeanSquaredError(__IntPtr textureLHS, __IntPtr textureRHS, uint MIPLevel, uint arrayMember, uint face, uint zSlice, PVRTexLibErrorMetrics metrics)
        {
            var __arg6 = metrics is null ? __IntPtr.Zero : metrics.__Instance;
            var ___ret = __Internal.PVRTexLibMeanSquaredError(textureLHS, textureRHS, MIPLevel, arrayMember, face, zSlice, __arg6);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="textureLHS">A handle to a previously allocated PVRTexLib_PVRTexture.</param>
        /// <param name="textureRHS">A handle to a previously allocated PVRTexLib_PVRTexture.</param>
        /// <param name="MIPLevel">The Mip to compare.</param>
        /// <param name="arrayMember">The array to compare.</param>
        /// <param name="face">The face to compare.</param>
        /// <param name="zSlice">The Z slice to compare.</param>
        /// <param name="metrics">Structure containing the resulting values.</param>
        /// <returns>
        /// <para>True if the method succeeds.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>
        /// <para>Computes the root mean squared error (RMSE) between two given</para>
        /// <para>input textures.</para>
        /// <para>The MIPLevel, arrayMember, face and zSlice values determine which</para>
        /// <para>surfaces are compared. NB: MIPLevel, arrayMember, face and zSlice</para>
        /// <para>should be valid in both input textures. Both textures must have the</para>
        /// <para>same dimensions. The function will only compare common channels i.e.</para>
        /// <para>if 'LHS' has RGB while 'RHS' has RGBA channels, then only the RGB</para>
        /// <para>channels will be compared.</para>
        /// </remarks>
        public static bool PVRTexLibRootMeanSquaredError(__IntPtr textureLHS, __IntPtr textureRHS, uint MIPLevel, uint arrayMember, uint face, uint zSlice, PVRTexLibErrorMetrics metrics)
        {
            var __arg6 = metrics is null ? __IntPtr.Zero : metrics.__Instance;
            var ___ret = __Internal.PVRTexLibRootMeanSquaredError(textureLHS, textureRHS, MIPLevel, arrayMember, face, zSlice, __arg6);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="textureLHS">A handle to a previously allocated PVRTexLib_PVRTexture.</param>
        /// <param name="textureRHS">A handle to a previously allocated PVRTexLib_PVRTexture.</param>
        /// <param name="MIPLevel">The Mip to compare.</param>
        /// <param name="arrayMember">The array to compare.</param>
        /// <param name="face">The face to compare.</param>
        /// <param name="zSlice">The Z slice to compare.</param>
        /// <param name="metrics">Structure containing the resulting values.</param>
        /// <returns>
        /// <para>True if the method succeeds.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>
        /// <para>Computes the standard deviation between two given input textures.</para>
        /// <para>The MIPLevel, arrayMember, face and zSlice values determine which</para>
        /// <para>surfaces are compared. NB: MIPLevel, arrayMember, face and zSlice</para>
        /// <para>should be valid in both input textures. Both textures must have the</para>
        /// <para>same dimensions. The function will only compare common channels i.e.</para>
        /// <para>if 'LHS' has RGB while 'RHS' has RGBA channels, then only the RGB</para>
        /// <para>channels will be compared.</para>
        /// </remarks>
        public static bool PVRTexLibStandardDeviation(__IntPtr textureLHS, __IntPtr textureRHS, uint MIPLevel, uint arrayMember, uint face, uint zSlice, PVRTexLibErrorMetrics metrics)
        {
            var __arg6 = metrics is null ? __IntPtr.Zero : metrics.__Instance;
            var ___ret = __Internal.PVRTexLibStandardDeviation(textureLHS, textureRHS, MIPLevel, arrayMember, face, zSlice, __arg6);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="textureLHS">A handle to a previously allocated PVRTexLib_PVRTexture.</param>
        /// <param name="textureRHS">A handle to a previously allocated PVRTexLib_PVRTexture.</param>
        /// <param name="MIPLevel">The Mip to compare.</param>
        /// <param name="arrayMember">The array to compare.</param>
        /// <param name="face">The face to compare.</param>
        /// <param name="zSlice">The Z slice to compare.</param>
        /// <param name="metrics">Structure containing the resulting values.</param>
        /// <returns>
        /// <para>True if the method succeeds.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>
        /// <para>Computes the PSNR between two given input textures.</para>
        /// <para>The MIPLevel, arrayMember, face and zSlice values determine which</para>
        /// <para>surfaces are compared. NB: MIPLevel, arrayMember, face and zSlice</para>
        /// <para>should be valid in both input textures. Both textures must have the</para>
        /// <para>same dimensions. The function will only compare common channels i.e.</para>
        /// <para>if 'LHS' has RGB while 'RHS' has RGBA channels, then only the RGB</para>
        /// <para>channels will be compared.</para>
        /// </remarks>
        public static bool PVRTexLibPeakSignalToNoiseRatio(__IntPtr textureLHS, __IntPtr textureRHS, uint MIPLevel, uint arrayMember, uint face, uint zSlice, PVRTexLibErrorMetrics metrics)
        {
            var __arg6 = metrics is null ? __IntPtr.Zero : metrics.__Instance;
            var ___ret = __Internal.PVRTexLibPeakSignalToNoiseRatio(textureLHS, textureRHS, MIPLevel, arrayMember, face, zSlice, __arg6);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="textureLHS">A handle to a previously allocated PVRTexLib_PVRTexture.</param>
        /// <param name="textureRHS">A handle to a previously allocated PVRTexLib_PVRTexture.</param>
        /// <param name="textureResult">PVRTexLib_PVRTexture that will contain the result on success.</param>
        /// <param name="multiplier">
        /// <para>The factor to multiply the deltas to highlight differences,</para>
        /// <para>generally a value between 1 and 10.</para>
        /// </param>
        /// <param name="mode">The clamping mode to use, currently supports absolute and signed.</param>
        /// <returns>
        /// <para>True if the method succeeds.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>
        /// <para>Computes the the [mode] delta per channel between two given</para>
        /// <para>input textures. Both textures must have the same dimensions and</para>
        /// <para>may not be compressed. The function will only compare common</para>
        /// <para>channels i.e. if 'LHS' has RGB while 'RHS' has RGBA channels,</para>
        /// <para>then only the RGB channels will be compared.</para>
        /// </remarks>
        public static bool PVRTexLibColourDiff(__IntPtr textureLHS, __IntPtr textureRHS, __IntPtr* textureResult, float multiplier, PVRTexLibColourDiffMode mode)
        {
            var ___ret = __Internal.PVRTexLibColourDiff(textureLHS, textureRHS, textureResult, multiplier, mode);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="textureLHS">A handle to a previously allocated PVRTexLib_PVRTexture.</param>
        /// <param name="textureRHS">A handle to a previously allocated PVRTexLib_PVRTexture.</param>
        /// <param name="textureResult">PVRTexLib_PVRTexture that will contain the result on success.</param>
        /// <param name="tolerance">The cut-off value to compare the pixel delta to.</param>
        /// <returns>
        /// <para>True if the method succeeds.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>
        /// <para>Computes the total absolute pixel difference between two given</para>
        /// <para>input textures and modulates the output based on the tolerance</para>
        /// <para>value supplied. Deltas of zero will appear black while pixels</para>
        /// <para>with deltas greater than or equal to the threshold are set to</para>
        /// <para>red and finally deltas less than the tolerance are set to blue.</para>
        /// <para>Both textures must have the same dimensions and may not be</para>
        /// <para>compressed. The function will only compare common channels i.e.</para>
        /// <para>if 'LHS' has RGB while 'RHS' has RGBA channels, then only the RGB</para>
        /// <para>channels will be compared.</para>
        /// </remarks>
        public static bool PVRTexLibToleranceDiff(__IntPtr textureLHS, __IntPtr textureRHS, __IntPtr* textureResult, float tolerance)
        {
            var ___ret = __Internal.PVRTexLibToleranceDiff(textureLHS, textureRHS, textureResult, tolerance);
            return ___ret;
        }

        /// <summary>***********************************************************************</summary>
        /// <param name="textureLHS">A handle to a previously allocated PVRTexLib_PVRTexture.</param>
        /// <param name="textureRHS">A handle to a previously allocated PVRTexLib_PVRTexture.</param>
        /// <param name="textureResult">PVRTexLib_PVRTexture that will contain the result on success.</param>
        /// <param name="blendFactor">
        /// <para>The blend weight to use in the blend equation:</para>
        /// <para>(LHS_delta * BF) + (RHS_delta * (1 - BF)). The value is clamped</para>
        /// <para>between 0 and 1.</para>
        /// </param>
        /// <returns>
        /// <para>True if the method succeeds.</para>
        /// <para>***********************************************************************</para>
        /// </returns>
        /// <remarks>
        /// <para>Blend each channel of the input textures using the blend factor</para>
        /// <para>as a weighting of the first texture against the second.</para>
        /// <para>Both textures must have the same dimensions and may not be</para>
        /// <para>compressed. The function will only blend common channels i.e.</para>
        /// <para>if 'LHS' has RGB while 'RHS' has RGBA channels, then only the RGB</para>
        /// <para>channels will be blended.</para>
        /// </remarks>
        public static bool PVRTexLibBlendDiff(__IntPtr textureLHS, __IntPtr textureRHS, __IntPtr* textureResult, float blendFactor)
        {
            var ___ret = __Internal.PVRTexLibBlendDiff(textureLHS, textureRHS, textureResult, blendFactor);
            return ___ret;
        }
    }

    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate __IntPtr Func___IntPtr_ulong(ulong allocSize);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate __IntPtr Func___IntPtr_uint(uint allocSize);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate byte* Func_bytePtr___IntPtr_ulong(__IntPtr privateData, ulong allocSize);
    }
}
